// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tradeforopp

//@version=5
indicator("ICT Killzones & Pivots [TFO]", "ICT Killzones & Pivots [TFO]", true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500)
//Smart Money Concepts [LuxAlgo]

//-------------------
// values to offset label on screen, para q la etiqueta no este pegado a la vela
// we use minimal time of bars as an offset in future 
var float minBarTime = 999999999999
currentTime = time(timeframe.period)
timeOfCurrentBar = ta.change(currentTime, 1)
minBarTime := not na(minBarTime) ? math.min(timeOfCurrentBar, minBarTime) : timeOfCurrentBar
//---------------


// ---------------------------------------- Inputs --------------------------------------------------
var g_SETTINGS      = "Settings"
max_days            = input.int(3, "Session Drawing Limit", 1, tooltip = "Only this many drawings will be kept on the chart, for each selected drawing type (killzone boxes, pivot lines, open lines, etc.)", group = g_SETTINGS)
tf_limit            = input.timeframe("30", "Timeframe Limit", tooltip = "Drawings will not appear on timeframes greater than or equal to this", group = g_SETTINGS)
gmt_tz              = input.string('GMT-4', "Timezone", options = ['GMT-12','GMT-11','GMT-10','GMT-9','GMT-8','GMT-7','GMT-6','GMT-5','GMT-4','GMT-3','GMT-2','GMT-1','GMT+0','GMT+1','GMT+2','GMT+3','GMT+4','GMT+5','GMT+6','GMT+7','GMT+8','GMT+9','GMT+10','GMT+11','GMT+12','GMT+13','GMT+14'], tooltip = "Note GMT is not adjusted to reflect Daylight Saving Time changes", group = g_SETTINGS)
lb_size             = input.string('Normal', "Label Size", options = ['Auto', 'Tiny', 'Small', 'Normal', 'Large', 'Huge'], group = g_SETTINGS)
lb_color            = input.color(color.black, "Label Text Color", group = g_SETTINGS)
use_cutoff          = input.bool(true, "Drawing Cutoff Time", inline = "CO", tooltip = "When enabled, all highs and lows will stop extending after this time", group = g_SETTINGS)
cutoff              = input.session("1200-1201", "", inline = "CO", group = g_SETTINGS)


var g_KZ            = "Killzones"
show_kz             = input.bool(true, "Show Killzone Boxes", inline = "KZ", group = g_KZ)
show_kz_text        = input.bool(true, "Display Text", inline = "KZ", group = g_KZ)
box_transparency    = input.int(70, "Box Transparency", 0, 100, group = g_KZ)
text_transparency   = input.int(50, "Text Transparency", 0, 100, group = g_KZ)

use_asia            = input.bool(true, "", inline = "ASIA", group = g_KZ)
asia_text           = input.string("Asia", "", inline = "ASIA", group = g_KZ)
asia                = input.session("2000-0000", "", inline = "ASIA", group = g_KZ)
as_color            = input.color(color.blue, "", inline = "ASIA", group = g_KZ)

use_london          = input.bool(true, "", inline = "LONDON", group = g_KZ)
london_text         = input.string("London", "", inline = "LONDON", group = g_KZ)
london              = input.session("0200-0500", "", inline = "LONDON", group = g_KZ)
lo_color            = input.color(color.red, "", inline = "LONDON", group = g_KZ)

use_nyam            = input.bool(true, "", inline = "NYAM", group = g_KZ)
nyam_text           = input.string("NY AM", "", inline = "NYAM", group = g_KZ)
nyam                = input.session("0930-1100", "", inline = "NYAM", group = g_KZ)
na_color            = input.color(#089981, "", inline = "NYAM", group = g_KZ)

use_nylu            = input.bool(true, "", inline = "NYLU", group = g_KZ)
nylu_text           = input.string("NY Lunch", "", inline = "NYLU", group = g_KZ)
nylu                = input.session("1200-1300", "", inline = "NYLU", group = g_KZ)
nl_color            = input.color(color.yellow, "", inline = "NYLU", group = g_KZ)

use_nypm            = input.bool(true, "", inline = "NYPM", group = g_KZ)
nypm_text           = input.string("NY PM", "", inline = "NYPM", group = g_KZ)
nypm                = input.session("1330-1600", "", inline = "NYPM", group = g_KZ)
np_color            = input.color(color.purple, "", inline = "NYPM", group = g_KZ)


var g_LABELS        = "Killzone Pivots"
show_pivots         = input.bool(true, "Show Pivots", inline = "PV", group = g_LABELS)
show_labels         = input.bool(true, "Show Labels", inline = "PV", group = g_LABELS)

ash_str             = input.string("AS.H", "Session 1 Labels", inline = "L_AS", group = g_LABELS)
asl_str             = input.string("AS.L", "", inline = "L_AS", group = g_LABELS)
as_alert            = input.bool(false, "Alerts", inline = "L_AS", group = g_LABELS)

loh_str             = input.string("LO.H", "Session 2 Labels", inline = "L_LO", group = g_LABELS)
lol_str             = input.string("LO.L", "", inline = "L_LO", group = g_LABELS)
lo_alert            = input.bool(false, "Alerts", inline = "L_LO", group = g_LABELS)

nah_str             = input.string("NYAM.H", "Session 3 Labels", inline = "L_NA", group = g_LABELS)
nal_str             = input.string("NYAM.L", "", inline = "L_NA", group = g_LABELS)
na_alert            = input.bool(false, "Alerts", inline = "L_NA", group = g_LABELS)

nlh_str             = input.string("NYL.H", "Session 4 Labels", inline = "L_NL", group = g_LABELS)
nll_str             = input.string("NYL.L", "", inline = "L_NL", group = g_LABELS)
nl_alert            = input.bool(false, "Alerts", inline = "L_NL", group = g_LABELS)

nph_str             = input.string("NYPM.H", "Session 5 Labels", inline = "L_NP", group = g_LABELS)
npl_str             = input.string("NYPM.L", "", inline = "L_NP", group = g_LABELS)
np_alert            = input.bool(false, "Alerts", inline = "L_NP", group = g_LABELS)

s_style             = input.string(defval = 'Solid', title = "Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "L_0", group = g_LABELS)
s_width             = input.int(1, "", inline = "L_0", group = g_LABELS)


var g_DWM           = "DWM Open"
dow_labels          = input.bool(true, "Day of Week Labels", inline = "DOW", group = g_DWM)
dow_yloc            = input.string('Bottom', "", options = ['Top', 'Bottom'], inline = "DOW", group = g_DWM)
dow_xloc            = input.string('Midnight', "", options = ['Midnight', 'Midday'], inline = "DOW", group = g_DWM)
dow_color           = input.color(color.black, "", inline = "DOW", group = g_DWM)

show_d_open         = input.bool(false, "", inline = "DO", group = g_DWM)
d_open_str          = input.string("D.OPEN", "", inline = "DO", group = g_DWM)
ds                  = input.bool(false, "Separators", inline = "DO", tooltip = "Mark where a new day begins. Unlimited will override the drawing limit", group = g_DWM)
ds_unlimited        = input.bool(true, "Unlimited", inline = "DO", group = g_DWM)
d_color             = input.color(color.blue, "", inline = "DO", group = g_DWM)

show_w_open         = input.bool(false, "", inline = "WO", group = g_DWM)
w_open_str          = input.string("W.OPEN", "", inline = "WO", group = g_DWM)
ws                  = input.bool(false, "Separators", inline = "WO", tooltip = "Mark where a new week begins. Unlimited will override the drawing limit", group = g_DWM)
ws_unlimited        = input.bool(true, "Unlimited", inline = "WO", group = g_DWM)
w_color             = input.color(#089981, "", inline = "WO", group = g_DWM)

show_m_open         = input.bool(false, "", inline = "MO", group = g_DWM)
m_open_str          = input.string("M.OPEN", "", inline = "MO", group = g_DWM)
ms                  = input.bool(false, "Separators", inline = "MO", tooltip = "Mark where a new month begins. Unlimited will override the drawing limit", group = g_DWM)
ms_unlimited        = input.bool(true, "Unlimited", inline = "MO", group = g_DWM)
m_color             = input.color(color.red, "", inline = "MO", group = g_DWM)

dwm_style           = input.string(defval = 'Solid', title = "Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "D0", group = g_DWM)
dwm_width           = input.int(1, "", inline = "D0", group = g_DWM)


var g_OPEN          = "Opening Price"
use_h1              = input.bool(true, "", inline = "H1", group = g_OPEN)
h1_text             = input.string("True Day Open", "", inline = "H1", group = g_OPEN)
h1                  = input.session("0000-0001", "", inline = "H1", group = g_OPEN)
h1_color            = input.color(color.black, "", inline = "H1", group = g_OPEN)

use_h2              = input.bool(false, "", inline = "H2", group = g_OPEN)
h2_text             = input.string("06:00", "", inline = "H2", group = g_OPEN)
h2                  = input.session("0600-0601", "", inline = "H2", group = g_OPEN)
h2_color            = input.color(color.black, "", inline = "H2", group = g_OPEN)

use_h3              = input.bool(false, "", inline = "H3", group = g_OPEN)
h3_text             = input.string("10:00", "", inline = "H3", group = g_OPEN)
h3                  = input.session("1000-1001", "", inline = "H3", group = g_OPEN)
h3_color            = input.color(color.black, "", inline = "H3", group = g_OPEN)

use_h4              = input.bool(false, "", inline = "H4", group = g_OPEN)
h4_text             = input.string("14:00", "", inline = "H4", group = g_OPEN)
h4                  = input.session("1400-1401", "", inline = "H4", group = g_OPEN)
h4_color            = input.color(color.black, "", inline = "H4", group = g_OPEN)

h_style             = input.string(defval = 'Dotted', title = "Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "H0", group = g_OPEN)
h_width             = input.int(1, "", inline = "H0", group = g_OPEN)


var g_VERTICAL      = "Timestamps"
use_v1              = input.bool(false, "", inline = "V1", group = g_VERTICAL)
v1                  = input.session("0000-0001", "", inline = "V1", group = g_VERTICAL)
v1_color            = input.color(color.black, "", inline = "V1", group = g_VERTICAL)

use_v2              = input.bool(false, "", inline = "V2", group = g_VERTICAL)
v2                  = input.session("0800-0801", "", inline = "V2", group = g_VERTICAL)
v2_color            = input.color(color.black, "", inline = "V2", group = g_VERTICAL)

use_v3              = input.bool(false, "", inline = "V3", group = g_VERTICAL)
v3                  = input.session("1000-1001", "", inline = "V3", group = g_VERTICAL)
v3_color            = input.color(color.black, "", inline = "V3", group = g_VERTICAL)

use_v4              = input.bool(true, "", inline = "V4", group = g_VERTICAL)
v4                  = input.session("1200-1201", "", inline = "V4", group = g_VERTICAL)
v4_color            = input.color(color.black, "", inline = "V4", group = g_VERTICAL)

v_style             = input.string(defval = 'Dotted', title = "Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "V0", group = g_VERTICAL)
v_width             = input.int(1, "", inline = "V0", group = g_VERTICAL)
// ---------------------------------------- Inputs --------------------------------------------------


// ---------------------------------------- Variables & Constants --------------------------------------------------
t_as = not na(time("", asia, gmt_tz))
t_lo = not na(time("", london, gmt_tz))
t_na = not na(time("", nyam, gmt_tz))
t_nl = not na(time("", nylu, gmt_tz))
t_np = not na(time("", nypm, gmt_tz))
t_co = not na(time("", cutoff, gmt_tz))

t_h1 = not na(time("", h1, gmt_tz))
t_h2 = not na(time("", h2, gmt_tz))
t_h3 = not na(time("", h3, gmt_tz))
t_h4 = not na(time("", h4, gmt_tz))

t_v1 = not na(time("", v1, gmt_tz))
t_v2 = not na(time("", v2, gmt_tz))
t_v3 = not na(time("", v3, gmt_tz))
t_v4 = not na(time("", v4, gmt_tz))

var as_hi_line = array.new_line()
var as_lo_line = array.new_line()
var lo_hi_line = array.new_line()
var lo_lo_line = array.new_line()
var na_hi_line = array.new_line()
var na_lo_line = array.new_line()
var nl_hi_line = array.new_line()
var nl_lo_line = array.new_line()
var np_hi_line = array.new_line()
var np_lo_line = array.new_line()

var d_sep_line = array.new_line()
var w_sep_line = array.new_line()
var m_sep_line = array.new_line()

var d_line = array.new_line()
var w_line = array.new_line()
var m_line = array.new_line()

var h1_line = array.new_line()
var h2_line = array.new_line()
var h3_line = array.new_line()
var h4_line = array.new_line()

var v1_line = array.new_line()
var v2_line = array.new_line()
var v3_line = array.new_line()
var v4_line = array.new_line()

var d_label = array.new_label()
var w_label = array.new_label()
var m_label = array.new_label()

var h1_label = array.new_label()
var h2_label = array.new_label()
var h3_label = array.new_label()
var h4_label = array.new_label()

var as_hi_label = array.new_label()
var as_lo_label = array.new_label()
var lo_hi_label = array.new_label()
var lo_lo_label = array.new_label()
var na_hi_label = array.new_label()
var na_lo_label = array.new_label()
var nl_hi_label = array.new_label()
var nl_lo_label = array.new_label()
var np_hi_label = array.new_label()
var np_lo_label = array.new_label()

var as_box = array.new_box()
var lo_box = array.new_box()
var na_box = array.new_box()
var nl_box = array.new_box()
var np_box = array.new_box()

transparent = #ffffff00

d_o = request.security(syminfo.tickerid, "D", open, barmerge.gaps_off, barmerge.lookahead_on)
w_o = request.security(syminfo.tickerid, "W", open, barmerge.gaps_off, barmerge.lookahead_on)
m_o = request.security(syminfo.tickerid, "M", open, barmerge.gaps_off, barmerge.lookahead_on)
// ---------------------------------------- Variables & Constants --------------------------------------------------


// ---------------------------------------- Functions --------------------------------------------------
get_label_size(_size) =>
    result = switch _size
        'Tiny' => size.tiny
        'Small' => size.small
        'Normal' => size.normal
        'Large' => size.large
        'Huge' => size.huge
        'Auto' => size.auto
    result

get_line_type(_style) =>
    result = switch _style
        'Solid' => line.style_solid
        'Dotted' => line.style_dotted
        'Dashed' => line.style_dashed
    result

get_box_color(_color, _transparency) =>
    result = color.new(_color, _transparency)
    
adjust(_hline, _lline, _hlabel, _llabel, _ulabel, _box) =>
    _hline.set_x2(bar_index)
    _lline.set_x2(bar_index)
    _box.set_right(bar_index)

    _top = show_kz ? _box.get_top() : _hline.get_y1()
    _bot = show_kz ? _box.get_bottom() : _lline.get_y1()

    if high > _top
        _hline.set_xy1(bar_index, high)
        _hline.set_y2(high)
        _box.set_top(high)

        _hlabel.set_x(bar_index)
        _hlabel.set_y(high)
    if low < _bot
        _lline.set_xy1(bar_index, low)
        _lline.set_y2(low)
        _box.set_bottom(low)

        _llabel.set_x(bar_index)
        _llabel.set_y(low)

check_high(_line) =>
    result = false
    broke = false
    _line.set_x2(bar_index)
    if high > _line.get_y1()
        result := true
        broke := true
    else if  (use_cutoff ? t_co : false)
        result := true
    [result, broke]
    
check_low(_line) =>
    result = false
    broke = false
    _line.set_x2(bar_index)
    if low < _line.get_y1()
        result := true
        broke := true
    else if (use_cutoff ? t_co : false)
        result := true
    [result, broke]
    
check_open(_line, _label) =>
    result = false
    _line.set_x2(bar_index)
    _label.set_x(bar_index)
    if (use_cutoff ? t_co : false)
        result := true
    result

check_array(_arr) =>
    if _arr.size() > max_days
        _arr.pop().delete()
// ---------------------------------------- Functions --------------------------------------------------


// ---------------------------------------- Core Logic --------------------------------------------------
s_style := get_line_type(s_style)
dwm_style := get_line_type(dwm_style)
h_style := get_line_type(h_style)
v_style := get_line_type(v_style)

lb_size := get_label_size(lb_size)

var color as_box_color = get_box_color(as_color, box_transparency)
var color lo_box_color = get_box_color(lo_color, box_transparency)
var color na_box_color = get_box_color(na_color, box_transparency)
var color nl_box_color = get_box_color(nl_color, box_transparency)
var color np_box_color = get_box_color(np_color, box_transparency)

var color as_text_color = get_box_color(as_color, text_transparency)
var color lo_text_color = get_box_color(lo_color, text_transparency)
var color na_text_color = get_box_color(na_color, text_transparency)
var color nl_text_color = get_box_color(nl_color, text_transparency)
var color np_text_color = get_box_color(np_color, text_transparency)

var h1_co = false
var h2_co = false
var h3_co = false
var h4_co = false

var as_stop_hi = false
var as_stop_lo = false

var lo_stop_hi = false
var lo_stop_lo = false

var na_stop_hi = false
var na_stop_lo = false

var nl_stop_hi = false
var nl_stop_lo = false

var np_stop_hi = false
var np_stop_lo = false

as_broke_hi = false
as_broke_lo = false

lo_broke_hi = false
lo_broke_lo = false

na_broke_hi = false
na_broke_lo = false

nl_broke_hi = false
nl_broke_lo = false

np_broke_hi = false
np_broke_lo = false

// day_str = switch dayofweek

// if dayofweek != dayofweek[1]
//     label.new(time, high, str.tostring(dayofweek))

if timeframe.in_seconds("") <= timeframe.in_seconds(tf_limit)
    // Asia
    if use_asia
        if t_as and not t_as[1]
            as_stop_hi := false
            as_stop_lo := false

            if show_kz
                as_box.unshift(box.new(bar_index, high, bar_index, low, border_color = as_box_color, bgcolor = as_box_color, text = show_kz_text ? asia_text : na, text_color = as_text_color))

            if show_pivots
                as_hi_line.unshift(line.new(bar_index, high, bar_index, high, style = s_style, color = as_color, width = s_width))
                as_lo_line.unshift(line.new(bar_index, low, bar_index, low, style = s_style, color = as_color, width = s_width))

            if show_labels
                as_hi_label.unshift(label.new(bar_index, high, ash_str, color = transparent, textcolor = lb_color, style = label.style_label_down, size = lb_size))
                as_lo_label.unshift(label.new(bar_index, low, asl_str, color = transparent, textcolor = lb_color, style = label.style_label_up, size = lb_size))
        else if t_as
            adjust(show_pivots ? as_hi_line.get(0) : na, show_pivots ? as_lo_line.get(0) : na, show_labels ? as_hi_label.get(0) : na, show_labels ? as_lo_label.get(0) : na, show_labels, show_kz ? as_box.get(0) : na)
        else if not t_as and as_hi_line.size() > 0
            if not as_stop_hi
                [_r, _b] = check_high(as_hi_line.get(0))
                if _r
                    as_stop_hi := true
                if _b
                    as_broke_hi := true
                    if as_alert
                        alert("Broke " + str.tostring(ash_str), alert.freq_once_per_bar)
            if not as_stop_lo
                [_r, _b] = check_low(as_lo_line.get(0))
                if _r
                    as_stop_lo := true
                if _b
                    as_broke_lo := true
                    if as_alert
                        alert("Broke " + str.tostring(asl_str), alert.freq_once_per_bar)
        
    // London
    if use_london
        if t_lo and not t_lo[1]
            lo_stop_hi := false
            lo_stop_lo := false

            if show_kz
                lo_box.unshift(box.new(bar_index, high, bar_index, low, border_color = lo_box_color, bgcolor = lo_box_color, text = show_kz_text ? london_text : na, text_color = lo_text_color))

            if show_pivots
                lo_hi_line.unshift(line.new(bar_index, high, bar_index, high, style = s_style, color = lo_color, width = s_width))
                lo_lo_line.unshift(line.new(bar_index, low, bar_index, low, style = s_style, color = lo_color, width = s_width))

            if show_labels
                lo_hi_label.unshift(label.new(bar_index, high, loh_str, color = transparent, textcolor = lb_color, style = label.style_label_down, size = lb_size))
                lo_lo_label.unshift(label.new(bar_index, low, lol_str, color = transparent, textcolor = lb_color, style = label.style_label_up, size = lb_size))
        else if t_lo
            adjust(show_pivots ? lo_hi_line.get(0) : na, show_pivots ? lo_lo_line.get(0) : na, show_labels ? lo_hi_label.get(0) : na, show_labels ? lo_lo_label.get(0) : na, show_labels, show_kz ? lo_box.get(0) : na)
        else if not t_lo and lo_hi_line.size() > 0
            if not lo_stop_hi
                [_r, _b] = check_high(lo_hi_line.get(0))
                if _r
                    lo_stop_hi := true
                if _b
                    lo_broke_hi := true
                    if lo_alert
                        alert("Broke " + str.tostring(loh_str), alert.freq_once_per_bar)
            if not lo_stop_lo
                [_r, _b] = check_low(lo_lo_line.get(0))
                if _r
                    lo_stop_lo := true
                if _b
                    lo_broke_lo := true
                    if lo_alert
                        alert("Broke " + str.tostring(lol_str), alert.freq_once_per_bar)
                        
    // NY AM
    if use_nyam
        if t_na and not t_na[1]
            na_stop_hi := false
            na_stop_lo := false

            if show_kz
                na_box.unshift(box.new(bar_index, high, bar_index, low, border_color = na_box_color, bgcolor = na_box_color, text = show_kz_text ? nyam_text : na, text_color = na_text_color))

            if show_pivots
                na_hi_line.unshift(line.new(bar_index, high, bar_index, high, style = s_style, color = na_color, width = s_width))
                na_lo_line.unshift(line.new(bar_index, low, bar_index, low, style = s_style, color = na_color, width = s_width))

            if show_labels
                na_hi_label.unshift(label.new(bar_index, high, nah_str, color = transparent, textcolor = lb_color, style = label.style_label_down, size = lb_size))
                na_lo_label.unshift(label.new(bar_index, low, nal_str, color = transparent, textcolor = lb_color, style = label.style_label_up, size = lb_size))
        else if t_na
            adjust(show_pivots ? na_hi_line.get(0) : na, show_pivots ? na_lo_line.get(0) : na, show_labels ? na_hi_label.get(0) : na, show_labels ? na_lo_label.get(0) : na, show_labels, show_kz ? na_box.get(0) : na)
        else if not t_na and na_hi_line.size() > 0
            if not na_stop_hi
                [_r, _b] = check_high(na_hi_line.get(0))
                if _r
                    na_stop_hi := true
                if _b
                    na_broke_hi := true
                    if na_alert
                        alert("Broke " + str.tostring(nah_str), alert.freq_once_per_bar)
            if not na_stop_lo
                [_r, _b] = check_low(na_lo_line.get(0))
                if _r
                    na_stop_lo := true
                if _b
                    na_broke_lo := true
                    if na_alert
                        alert("Broke " + str.tostring(nal_str), alert.freq_once_per_bar)
                        
    // NY Lunch
    if use_nylu
        if t_nl and not t_nl[1]
            nl_stop_hi := false
            nl_stop_lo := false

            if show_kz
                nl_box.unshift(box.new(bar_index, high, bar_index, low, border_color = nl_box_color, bgcolor = nl_box_color, text = show_kz_text ? nylu_text : na, text_color = nl_text_color))

            if show_pivots
                nl_hi_line.unshift(line.new(bar_index, high, bar_index, high, style = s_style, color = nl_color, width = s_width))
                nl_lo_line.unshift(line.new(bar_index, low, bar_index, low, style = s_style, color = nl_color, width = s_width))

            if show_labels
                nl_hi_label.unshift(label.new(bar_index, high, nlh_str, color = transparent, textcolor = lb_color, style = label.style_label_down, size = lb_size))
                nl_lo_label.unshift(label.new(bar_index, low, nll_str, color = transparent, textcolor = lb_color, style = label.style_label_up, size = lb_size))
        else if t_nl
            adjust(show_pivots ? nl_hi_line.get(0) : na, show_pivots ? nl_lo_line.get(0) : na, show_labels ? nl_hi_label.get(0) : na, show_labels ? nl_lo_label.get(0) : na, show_labels, show_kz ? nl_box.get(0) : na)
        else if not t_nl and nl_hi_line.size() > 0
            if not nl_stop_hi
                [_r, _b] = check_high(nl_hi_line.get(0))
                if _r
                    nl_stop_hi := true
                if _b
                    nl_broke_hi := true
                    if nl_alert
                        alert("Broke " + str.tostring(nlh_str), alert.freq_once_per_bar)
            if not nl_stop_lo
                [_r, _b] = check_low(nl_lo_line.get(0))
                if _r
                    nl_stop_lo := true
                if _b
                    nl_broke_lo := true
                    if nl_alert
                        alert("Broke " + str.tostring(nll_str), alert.freq_once_per_bar)
                        
    // NY PM
    if use_nypm
        if t_np and not t_np[1]
            np_stop_hi := false
            np_stop_lo := false

            if show_kz
                np_box.unshift(box.new(bar_index, high, bar_index, low, border_color = np_box_color, bgcolor = np_box_color, text = show_kz_text ? nypm_text : na, text_color = np_text_color))

            if show_pivots
                np_hi_line.unshift(line.new(bar_index, high, bar_index, high, style = s_style, color = np_color, width = s_width))
                np_lo_line.unshift(line.new(bar_index, low, bar_index, low, style = s_style, color = np_color, width = s_width))

            if show_labels
                np_hi_label.unshift(label.new(bar_index, high, nph_str, color = transparent, textcolor = lb_color, style = label.style_label_down, size = lb_size))
                np_lo_label.unshift(label.new(bar_index, low, npl_str, color = transparent, textcolor = lb_color, style = label.style_label_up, size = lb_size))
        else if t_np
            adjust(show_pivots ? np_hi_line.get(0) : na, show_pivots ? np_lo_line.get(0) : na, show_labels ? np_hi_label.get(0) : na, show_labels ? np_lo_label.get(0) : na, show_labels, show_kz ? np_box.get(0) : na) 
        else if not t_np and np_hi_line.size() > 0
            if not np_stop_hi
                [_r, _b] = check_high(np_hi_line.get(0))
                if _r
                    np_stop_hi := true
                if _b
                    np_broke_hi := true
                    if np_alert
                        alert("Broke " + str.tostring(nph_str), alert.freq_once_per_bar)
            if not np_stop_lo
                [_r, _b] = check_low(np_lo_line.get(0))
                if _r
                    np_stop_lo := true
                if _b
                    np_broke_lo := true
                    if np_alert
                        alert("Broke " + str.tostring(npl_str), alert.freq_once_per_bar)
                
    // Vertical Lines
    if use_v1
        if t_v1 and not t_v1[1]
            v1_line.unshift(line.new(bar_index, high, bar_index, low, style = v_style, width = v_width, extend = extend.both, color = v1_color))
    if use_v2
        if t_v2 and not t_v2[1]
            v2_line.unshift(line.new(bar_index, high, bar_index, low, style = v_style, width = v_width, extend = extend.both, color = v2_color))
    if use_v3
        if t_v3 and not t_v3[1]
            v3_line.unshift(line.new(bar_index, high, bar_index, low, style = v_style, width = v_width, extend = extend.both, color = v3_color))
    if use_v4
        if t_v4 and not t_v4[1]
            v4_line.unshift(line.new(bar_index, high, bar_index, low, style = v_style, width = v_width, extend = extend.both, color = v4_color))

    // Horizontal Lines
    if use_h1
        if t_h1 and not t_h1[1]
            h1_co := false
            
            h1_line.unshift(line.new(bar_index, open, bar_index, open, style = h_style, width = h_width, color = h1_color))
            h1_label.unshift(label.new(bar_index, open, h1_text, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if not t_h1 and h1_line.size() > 0
            if not h1_co
                if not check_open(h1_line.get(0), h1_label.get(0))
                    h1_label.get(0).set_x(bar_index)
                else
                    h1_co := true
                
    if use_h2
        if t_h2 and not t_h2[1]
            h2_co := false
            
            h2_line.unshift(line.new(bar_index, open, bar_index, open, style = h_style, width = h_width, color = h2_color))
            h2_label.unshift(label.new(bar_index, open, h2_text, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if not t_h2 and h2_line.size() > 0
            if not h2_co 
                if not check_open(h2_line.get(0), h2_label.get(0))
                    h2_label.get(0).set_x(bar_index)
                else
                    h2_co := true
                
    if use_h3
        if t_h3 and not t_h3[1]
            h3_co := false
            
            h3_line.unshift(line.new(bar_index, open, bar_index, open, style = h_style, width = h_width, color = h3_color))
            h3_label.unshift(label.new(bar_index, open, h3_text, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if not t_h3 and h3_line.size() > 0
            if not h3_co
                if not check_open(h3_line.get(0), h3_label.get(0))
                    h3_label.get(0).set_x(bar_index)
                else
                    h3_co := true
                
    if use_h4
        if t_h4 and not t_h4[1]
            h4_co := false
            
            h4_line.unshift(line.new(bar_index, open, bar_index, open, style = h_style, width = h_width, color = h4_color))
            h4_label.unshift(label.new(bar_index, open, h4_text, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if not t_h4 and h4_line.size() > 0
            if not h4_co
                if not check_open(h4_line.get(0), h4_label.get(0))
                    h4_label.get(0).set_x(bar_index)
                else
                    h4_co := true

    // DWM - Separators
    if ds
        if d_o != d_o[1]
            d_sep_line.unshift(line.new(bar_index, high, bar_index, low, style = dwm_style, width = dwm_width, extend = extend.both, color = d_color))
    if ws
        if w_o != w_o[1]
            w_sep_line.unshift(line.new(bar_index, high, bar_index, low, style = dwm_style, width = dwm_width, extend = extend.both, color = w_color))
    if ms
        if m_o != m_o[1]
            m_sep_line.unshift(line.new(bar_index, high, bar_index, low, style = dwm_style, width = dwm_width, extend = extend.both, color = m_color))

    // DWM - Open Lines
    if show_d_open
        if d_o != d_o[1]
            d_line.unshift(line.new(bar_index, d_o, bar_index, d_o, style = dwm_style, width = dwm_width, color = d_color))
            d_label.unshift(label.new(bar_index, d_o, d_open_str, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if d_line.size() > 0
            if not check_open(d_line.get(0), d_label.get(0))
                d_label.get(0).set_x(bar_index)
                
    if show_w_open
        if w_o != w_o[1]
            w_line.unshift(line.new(bar_index, w_o, bar_index, w_o, style = dwm_style, width = dwm_width, color = w_color))
            w_label.unshift(label.new(bar_index, w_o, w_open_str, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if w_line.size() > 0
            if not check_open(w_line.get(0), w_label.get(0))
                w_label.get(0).set_x(bar_index)
                
    if show_m_open
        if m_o != m_o[1]
            m_line.unshift(line.new(bar_index, m_o, bar_index, m_o, style = dwm_style, width = dwm_width, color = m_color))
            m_label.unshift(label.new(bar_index, m_o, m_open_str, style = label.style_label_left, color = transparent, textcolor = lb_color, size = lb_size))
        else if m_line.size() > 0
            if not check_open(m_line.get(0), m_label.get(0))
                m_label.get(0).set_x(bar_index)

new_dow_time = dow_xloc == 'Midday' ? time - timeframe.in_seconds("D") / 2 * 1000 : time
new_day = dayofweek(new_dow_time, gmt_tz) != dayofweek(new_dow_time, gmt_tz)[1]
dow_top = dow_yloc == 'Top'

monday = "MONDAY"
tuesday = "TUESDAY"
wednesday = "WEDNESDAY"
thursday = "THURSDAY"
friday = "FRIDAY"

plotchar(dow_labels and timeframe.isintraday and dayofweek(new_dow_time, gmt_tz) == 2 and new_day, location = dow_top ? location.top : location.bottom, char = "", textcolor = dow_color, text = monday)
plotchar(dow_labels and timeframe.isintraday and dayofweek(new_dow_time, gmt_tz) == 3 and new_day, location = dow_top ? location.top : location.bottom, char = "", textcolor = dow_color, text = tuesday)
plotchar(dow_labels and timeframe.isintraday and dayofweek(new_dow_time, gmt_tz) == 4 and new_day, location = dow_top ? location.top : location.bottom, char = "", textcolor = dow_color, text = wednesday)
plotchar(dow_labels and timeframe.isintraday and dayofweek(new_dow_time, gmt_tz) == 5 and new_day, location = dow_top ? location.top : location.bottom, char = "", textcolor = dow_color, text = thursday)
plotchar(dow_labels and timeframe.isintraday and dayofweek(new_dow_time, gmt_tz) == 6 and new_day, location = dow_top ? location.top : location.bottom, char = "", textcolor = dow_color, text = friday)

check_array(as_hi_line)
check_array(as_lo_line)
check_array(as_hi_label)
check_array(as_lo_label)
check_array(as_box)

check_array(lo_hi_line)
check_array(lo_lo_line)
check_array(lo_hi_label)
check_array(lo_lo_label)
check_array(lo_box)

check_array(na_hi_line)
check_array(na_lo_line)
check_array(na_hi_label)
check_array(na_lo_label)
check_array(na_box)

check_array(nl_hi_line)
check_array(nl_lo_line)
check_array(nl_hi_label)
check_array(nl_lo_label)
check_array(nl_box)

check_array(np_hi_line)
check_array(np_lo_line)
check_array(np_hi_label)
check_array(np_lo_label)
check_array(np_box)

check_array(v1_line)
check_array(v2_line)
check_array(v3_line)
check_array(v4_line)

check_array(h1_line)
check_array(h2_line)
check_array(h3_line)
check_array(h4_line)

check_array(h1_label)
check_array(h2_label)
check_array(h3_label)
check_array(h4_label)

if not ds_unlimited
    check_array(d_sep_line)
    check_array(d_line)
    check_array(d_label)
if not ws_unlimited
    check_array(w_sep_line)
    check_array(w_line)
    check_array(w_label)
if not ms_unlimited
    check_array(m_sep_line)
    check_array(m_line)
    check_array(m_label)
// ---------------------------------------- Core Logic --------------------------------------------------


// indicator("Smart Money Concepts [LuxAlgo]", "Smart Money Concepts [LuxAlgo]"
//   , overlay = true
//   , max_labels_count = 500
//   , max_lines_count = 500
//   , max_boxes_count = 500
//   , max_bars_back = 500)
//-----------------------------------------------------------------------------{
//Constants
//-----------------------------------------------------------------------------{
color TRANSP_CSS = #ffffff00

//Tooltips
string MODE_TOOLTIP          = 'Allows to display historical Structure or only the recent ones'
string STYLE_TOOLTIP         = 'Indicator color theme'
string COLOR_CANDLES_TOOLTIP = 'Display additional candles with a color reflecting the current trend detected by structure'
string SHOW_INTERNAL         = 'Display internal market structure'
string CONFLUENCE_FILTER     = 'Filter non significant internal structure breakouts'
string SHOW_SWING            = 'Display swing market Structure'
string SHOW_SWING_POINTS     = 'Display swing point as labels on the chart'
string SHOW_SWHL_POINTS      = 'Highlight most recent strong and weak high/low points on the chart'
string INTERNAL_OB           = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
string SWING_OB              = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
string FILTER_OB             = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
string SHOW_EQHL             = 'Display equal highs and equal lows on the chart'
string EQHL_BARS             = 'Number of bars used to confirm equal highs and equal lows'
string EQHL_THRESHOLD        = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
string SHOW_FVG              = 'Display fair values gaps on the chart'
string AUTO_FVG              = 'Filter out non significant fair value gaps'
string FVG_TF                = 'Fair value gaps timeframe'
string EXTEND_FVG            = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
string PED_ZONES             = 'Display premium, discount, and equilibrium zones on chart'

//-----------------------------------------------------------------------------{
//Settings
//-----------------------------------------------------------------------------{
//General
//----------------------------------------{
mode = input.string('Historical'
  , options = ['Historical', 'Present']
  , group = 'Smart Money Concepts'
  , tooltip = MODE_TOOLTIP)

style = input.string('Colored'
  , options = ['Colored', 'Monochrome']
  , group = 'Smart Money Concepts'
  , tooltip = STYLE_TOOLTIP)

show_trend = input(false, 'Color Candles'
  , group = 'Smart Money Concepts'
  , tooltip = COLOR_CANDLES_TOOLTIP)

//----------------------------------------}
//Internal Structure
//----------------------------------------{
show_internals = input(true, 'Show Internal Structure'
  , group = 'Real Time Internal Structure'
  , tooltip = SHOW_INTERNAL)

show_ibull = input.string('All', 'Bullish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'ibull'
  , group = 'Real Time Internal Structure')

swing_ibull_css = input(#089981, ''
  , inline = 'ibull'
  , group = 'Real Time Internal Structure')

//Bear Structure
show_ibear = input.string('All', 'Bearish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'ibear'
  , group = 'Real Time Internal Structure')

swing_ibear_css = input(#f23645, ''
  , inline = 'ibear'
  , group = 'Real Time Internal Structure')

ifilter_confluence = input(false, 'Confluence Filter'
  , group = 'Real Time Internal Structure'
  , tooltip = CONFLUENCE_FILTER)

internal_structure_size = input.string('Tiny', 'Internal Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'Real Time Internal Structure')

//----------------------------------------}
//Swing Structure
//----------------------------------------{
show_Structure = input(true, 'Show Swing Structure'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWING)

//Bull Structure
show_bull = input.string('All', 'Bullish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'bull'
  , group = 'Real Time Swing Structure')

swing_bull_css = input(#089981, ''
  , inline = 'bull'
  , group = 'Real Time Swing Structure')

//Bear Structure
show_bear = input.string('All', 'Bearish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'bear'
  , group = 'Real Time Swing Structure')

swing_bear_css = input(#f23645, ''
  , inline = 'bear'
  , group = 'Real Time Swing Structure')

swing_structure_size = input.string('Small', 'Swing Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'Real Time Swing Structure')

//Swings
show_swings = input(false, 'Show Swings Points'
  , inline = 'swings'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWING_POINTS)

length = input.int(50, ''
  , minval = 10
  , inline = 'swings'
  , group = 'Real Time Swing Structure')

show_hl_swings = input(true, 'Show Strong/Weak High/Low'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWHL_POINTS)

//----------------------------------------}
//Order Blocks
//----------------------------------------{
show_iob = input(true, 'Internal Order Blocks'
  , inline = 'iob'
  , group = 'Order Blocks'
  , tooltip = INTERNAL_OB)

iob_showlast = input.int(5, ''
  , minval = 1
  , inline = 'iob'
  , group = 'Order Blocks')

show_ob = input(false, 'Swing Order Blocks'
  , inline = 'ob'
  , group = 'Order Blocks'
  , tooltip = SWING_OB)

ob_showlast = input.int(5, ''
  , minval = 1
  , inline = 'ob'
  , group = 'Order Blocks')

ob_filter = input.string('Atr', 'Order Block Filter'
  , options = ['Atr', 'Cumulative Mean Range']
  , group = 'Order Blocks'
  , tooltip = FILTER_OB)

ibull_ob_css = input.color(color.new(#3179f5, 80), 'Internal Bullish OB'
  , group = 'Order Blocks')

ibear_ob_css = input.color(color.new(#f77c80, 80), 'Internal Bearish OB'
  , group = 'Order Blocks')

bull_ob_css = input.color(color.new(#1848cc, 80), 'Bullish OB'
  , group = 'Order Blocks')

bear_ob_css = input.color(color.new(#b22833, 80), 'Bearish OB'
  , group = 'Order Blocks')

//----------------------------------------}
//EQH/EQL
//----------------------------------------{
show_eq = input(true, 'Equal High/Low'
  , group = 'EQH/EQL'
  , tooltip = SHOW_EQHL)

eq_len = input.int(3, 'Bars Confirmation'
  , minval = 1
  , group = 'EQH/EQL'
  , tooltip = EQHL_BARS)

eq_threshold = input.float(0.1, 'Threshold'
  , minval = 0
  , maxval = 0.5
  , step = 0.1
  , group = 'EQH/EQL'
  , tooltip = EQHL_THRESHOLD)

eq_size = input.string('Tiny', 'Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'EQH/EQL')

//----------------------------------------}
//Fair Value Gaps
//----------------------------------------{
show_fvg = input(false, 'Fair Value Gaps'
  , group = 'Fair Value Gaps'
  , tooltip = SHOW_FVG)
  
fvg_auto = input(true, "Auto Threshold"
  , group = 'Fair Value Gaps'
  , tooltip = AUTO_FVG)

fvg_tf = input.timeframe('', "Timeframe"
  , group = 'Fair Value Gaps'
  , tooltip = FVG_TF)

bull_fvg_css = input.color(color.new(#00ff68, 70), 'Bullish FVG'
  , group = 'Fair Value Gaps')

bear_fvg_css = input.color(color.new(#ff0008, 70), 'Bearish FVG'
  , group = 'Fair Value Gaps')

fvg_extend = input.int(1, "Extend FVG"
  , minval = 0
  , group = 'Fair Value Gaps'
  , tooltip = EXTEND_FVG)

//----------------------------------------}
//Previous day/week high/low
//----------------------------------------{
//Daily
show_pdhl = input(false, 'Daily'
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

pdhl_style = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

pdhl_css = input(#2157f3, ''
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

//Weekly
show_pwhl = input(false, 'Weekly'
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

pwhl_style = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

pwhl_css = input(#2157f3, ''
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

//Monthly
show_pmhl = input(false, 'Monthly'
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

pmhl_style = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

pmhl_css = input(#2157f3, ''
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

//----------------------------------------}
//Premium/Discount zones
//----------------------------------------{
show_sd = input(false, 'Premium/Discount Zones'
  , group = 'Premium & Discount Zones'
  , tooltip = PED_ZONES)

premium_css = input.color(#f23645, 'Premium Zone'
  , group = 'Premium & Discount Zones')

eq_css = input.color(#b2b5be, 'Equilibrium Zone'
  , group = 'Premium & Discount Zones')

discount_css = input.color(#089981, 'Discount Zone'
  , group = 'Premium & Discount Zones')

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
n = bar_index

atr = ta.atr(200)
cmean_range = ta.cum(high - low) / n

//HL Output function
hl() => [high, low]

//Get ohlc values function
get_ohlc()=> [close[1], open[1], high, low, high[2], low[2]]

//Display Structure function
display_Structure(x, y, txt, css, dashed, down, lbl_size)=>
    structure_line = line.new(x, y, n, y
      , color = css
      , style = dashed ? line.style_dashed : line.style_solid)

    structure_lbl = label.new(int(math.avg(x, n)), y, txt
      , color = TRANSP_CSS
      , textcolor = css
      , style = down ? label.style_label_down : label.style_label_up
      , size = lbl_size)

    if mode == 'Present'
        line.delete(structure_line[1])
        label.delete(structure_lbl[1])

//Swings detection/measurements
swings(len)=>
    var os = 0
    
    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]

    top = os == 0 and os[1] != 0 ? high[len] : 0
    btm = os == 1 and os[1] != 1 ? low[len] : 0

    [top, btm]

//Order block coordinates function
ob_coord(use_max, loc, target_top, target_btm, target_left, target_type)=>
    min = 99999999.
    max = 0.
    idx = 1

    ob_threshold = ob_filter == 'Atr' ? atr : cmean_range 

    //Search for highest/lowest high within the structure interval and get range
    if use_max
        for i = 1 to (n - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                max := math.max(high[i], max)
                min := max == high[i] ? low[i] : min
                idx := max == high[i] ? i : idx
    else
        for i = 1 to (n - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                min := math.min(low[i], min)
                max := min == low[i] ? high[i] : max
                idx := min == low[i] ? i : idx

    array.unshift(target_top, max)
    array.unshift(target_btm, min)
    array.unshift(target_left, time[idx])
    array.unshift(target_type, use_max ? -1 : 1)

//Set order blocks
display_ob(boxes, target_top, target_btm, target_left, target_type, show_last, swing, size)=>
    for i = 0 to math.min(show_last-1, size-1)
        get_box = array.get(boxes, i)

        box.set_lefttop(get_box, array.get(target_left, i), array.get(target_top, i))
        box.set_rightbottom(get_box, array.get(target_left, i), array.get(target_btm, i))
        box.set_extend(get_box, extend.right)

        color css = na
        
        if swing 
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
                border_css = array.get(target_type, i) == 1 ? #b2b5be : #5d606b
                box.set_border_color(get_box, border_css)
            else
                css := array.get(target_type, i) == 1 ? bull_ob_css : bear_ob_css
                box.set_border_color(get_box, css)

            box.set_bgcolor(get_box, css)
        else
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
            else
                css := array.get(target_type, i) == 1 ? ibull_ob_css : ibear_ob_css
            
            box.set_border_color(get_box, css)
            box.set_bgcolor(get_box, css)
        
//Line Style function
get_line_style(style) =>
    out = switch style
        '⎯⎯⎯'  => line.style_solid
        '----' => line.style_dashed
        '····' => line.style_dotted

//Set line/labels function for previous high/lows
phl(h, l, tf, css)=>
    var line high_line = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = get_line_style(pdhl_style))

    var label high_lbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format('P{0}H', tf)
      , color = TRANSP_CSS
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)

    var line low_line = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = get_line_style(pdhl_style))

    var label low_lbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format('P{0}L', tf)
      , color = TRANSP_CSS
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)

    hy = ta.valuewhen(h != h[1], h, 1)
    hx = ta.valuewhen(h == high, time, 1)

    ly = ta.valuewhen(l != l[1], l, 1)
    lx = ta.valuewhen(l == low, time, 1)

    if barstate.islast
        ext = time + (time - time[1])*20

        //High
        line.set_xy1(high_line, hx, hy)
        line.set_xy2(high_line, ext, hy)

        label.set_xy(high_lbl, ext, hy)

        //Low
        line.set_xy1(low_line, lx, ly)
        line.set_xy2(low_line, ext, ly)

        label.set_xy(low_lbl, ext, ly)

//-----------------------------------------------------------------------------}
//Global variables
//-----------------------------------------------------------------------------{
var trend = 0, var itrend = 0

var top_y = 0., var top_x = 0
var btm_y = 0., var btm_x = 0

var itop_y = 0., var itop_x = 0
var ibtm_y = 0., var ibtm_x = 0

var trail_up = high, var trail_dn = low
var trail_up_x = 0,  var trail_dn_x = 0

var top_cross = true,  var btm_cross = true
var itop_cross = true, var ibtm_cross = true

var txt_top = '',  var txt_btm = ''

//Alerts
bull_choch_alert = false 
bull_bos_alert   = false 

bear_choch_alert = false 
bear_bos_alert   = false 

bull_ichoch_alert = false 
bull_ibos_alert   = false 

bear_ichoch_alert = false 
bear_ibos_alert   = false 

bull_iob_break = false 
bear_iob_break = false

bull_ob_break = false 
bear_ob_break = false

eqh_alert = false 
eql_alert = false 

//Structure colors
var bull_css = style == 'Monochrome' ? #b2b5be 
  : swing_bull_css

var bear_css = style == 'Monochrome' ? #b2b5be 
  : swing_bear_css

var ibull_css = style == 'Monochrome' ? #b2b5be 
  : swing_ibull_css

var ibear_css = style == 'Monochrome' ? #b2b5be 
  : swing_ibear_css

//Labels size
var internal_structure_lbl_size = internal_structure_size == 'Tiny' 
  ? size.tiny 
  : internal_structure_size == 'Small' 
  ? size.small 
  : size.normal 

var swing_structure_lbl_size = swing_structure_size == 'Tiny' 
  ? size.tiny 
  : swing_structure_size == 'Small' 
  ? size.small 
  : size.normal 

var eqhl_lbl_size = eq_size == 'Tiny' 
  ? size.tiny 
  : eq_size == 'Small' 
  ? size.small
  : size.normal 

//Swings
[top, btm] = swings(length)

[itop, ibtm] = swings(5)

//-----------------------------------------------------------------------------}
//Pivot High
//-----------------------------------------------------------------------------{
var line extend_top = na

var label extend_top_lbl = label.new(na, na
  , color = TRANSP_CSS
  , textcolor = bear_css
  , style = label.style_label_down
  , size = size.tiny)

if top
    top_cross := true
    txt_top := top > top_y ? 'HH' : 'LH'

    if show_swings
        top_lbl = label.new(n-length, top, txt_top
          , color = TRANSP_CSS
          , textcolor = bear_css
          , style = label.style_label_down
          , size = swing_structure_lbl_size)

        if mode == 'Present'
            label.delete(top_lbl[1])

    //Extend recent top to last bar
    line.delete(extend_top[1])
    extend_top := line.new(n-length, top, n, top
      , color = bear_css)

    top_y := top
    top_x := n - length

    trail_up := top
    trail_up_x := n - length

if itop
    itop_cross := true

    itop_y := itop
    itop_x := n - 5

//Trailing maximum
trail_up := math.max(high, trail_up)
trail_up_x := trail_up == high ? n : trail_up_x

//Set top extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_top, trail_up_x, trail_up)
    line.set_xy2(extend_top, n + 20, trail_up)

    label.set_x(extend_top_lbl, n + 20)
    label.set_y(extend_top_lbl, trail_up)
    label.set_text(extend_top_lbl, trend < 0 ? 'Strong High' : 'Weak High')

//-----------------------------------------------------------------------------}
//Pivot Low
//-----------------------------------------------------------------------------{
var line extend_btm = na 

var label extend_btm_lbl = label.new(na, na
  , color = TRANSP_CSS
  , textcolor = bull_css
  , style = label.style_label_up
  , size = size.tiny)

if btm
    btm_cross := true
    txt_btm := btm < btm_y ? 'LL' : 'HL'
    
    if show_swings
        btm_lbl = label.new(n - length, btm, txt_btm
          , color = TRANSP_CSS
          , textcolor = bull_css
          , style = label.style_label_up
          , size = swing_structure_lbl_size)

        if mode == 'Present'
            label.delete(btm_lbl[1])
    
    //Extend recent btm to last bar
    line.delete(extend_btm[1])
    extend_btm := line.new(n - length, btm, n, btm
      , color = bull_css)

    btm_y := btm
    btm_x := n-length

    trail_dn := btm
    trail_dn_x := n-length

if ibtm
    ibtm_cross := true

    ibtm_y := ibtm
    ibtm_x := n - 5

//Trailing minimum
trail_dn := math.min(low, trail_dn)
trail_dn_x := trail_dn == low ? n : trail_dn_x

//Set btm extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_btm, trail_dn_x, trail_dn)
    line.set_xy2(extend_btm, n + 20, trail_dn)

    label.set_x(extend_btm_lbl, n + 20)
    label.set_y(extend_btm_lbl, trail_dn)
    label.set_text(extend_btm_lbl, trend > 0 ? 'Strong Low' : 'Weak Low')

//-----------------------------------------------------------------------------}
//Order Blocks Arrays
//-----------------------------------------------------------------------------{
var iob_top = array.new_float(0)
var iob_btm = array.new_float(0)
var iob_left = array.new_int(0)
var iob_type = array.new_int(0)

var ob_top = array.new_float(0)
var ob_btm = array.new_float(0)
var ob_left = array.new_int(0)
var ob_type = array.new_int(0)

//-----------------------------------------------------------------------------}
//Pivot High BOS/CHoCH
//-----------------------------------------------------------------------------{
//Filtering
var bull_concordant = true

if ifilter_confluence
    bull_concordant := high - math.max(close, open) > math.min(close, open - low)

//Detect internal bullish Structure
if ta.crossover(close, itop_y) and itop_cross and top_y != itop_y and bull_concordant
    bool choch = na
    
    if itrend < 0
        choch := true
        bull_ichoch_alert := true
    else 
        bull_ibos_alert := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    if show_internals
        if show_ibull == 'All' or (show_ibull == 'BOS' and not choch) or (show_ibull == 'CHoCH' and choch)
            display_Structure(itop_x, itop_y, txt, ibull_css, true, true, internal_structure_lbl_size)
    
    itop_cross := false
    itrend := 1
    
    //Internal Order Block
    if show_iob
        ob_coord(false, itop_x, iob_top, iob_btm, iob_left, iob_type)

//Detect bullish Structure
if ta.crossover(close, top_y) and top_cross
    bool choch = na
    
    if trend < 0
        choch := true
        bull_choch_alert := true
    else 
        bull_bos_alert := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    if show_Structure
        if show_bull == 'All' or (show_bull == 'BOS' and not choch) or (show_bull == 'CHoCH' and choch)
            display_Structure(top_x, top_y, txt, bull_css, false, true, swing_structure_lbl_size)
    
    //Order Block
    if show_ob
        ob_coord(false, top_x, ob_top, ob_btm, ob_left, ob_type)

    top_cross := false
    trend := 1

//-----------------------------------------------------------------------------}
//Pivot Low BOS/CHoCH
//-----------------------------------------------------------------------------{
var bear_concordant = true

if ifilter_confluence
    bear_concordant := high - math.max(close, open) < math.min(close, open - low)

//Detect internal bearish Structure
if ta.crossunder(close, ibtm_y) and ibtm_cross and btm_y != ibtm_y and bear_concordant
    bool choch = false
    
    if itrend > 0
        choch := true
        bear_ichoch_alert := true
    else 
        bear_ibos_alert := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    if show_internals
        if show_ibear == 'All' or (show_ibear == 'BOS' and not choch) or (show_ibear == 'CHoCH' and choch)
            display_Structure(ibtm_x, ibtm_y, txt, ibear_css, true, false, internal_structure_lbl_size)
    
    ibtm_cross := false
    itrend := -1
    
    //Internal Order Block
    if show_iob
        ob_coord(true, ibtm_x, iob_top, iob_btm, iob_left, iob_type)

//Detect bearish Structure
if ta.crossunder(close, btm_y) and btm_cross
    bool choch = na
    
    if trend > 0
        choch := true
        bear_choch_alert := true
    else 
        bear_bos_alert := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    if show_Structure
        if show_bear == 'All' or (show_bear == 'BOS' and not choch) or (show_bear == 'CHoCH' and choch)
            display_Structure(btm_x, btm_y, txt, bear_css, false, false, swing_structure_lbl_size)
    
    //Order Block
    if show_ob
        ob_coord(true, btm_x, ob_top, ob_btm, ob_left, ob_type)

    btm_cross := false
    trend := -1

//-----------------------------------------------------------------------------}
//Order Blocks
//-----------------------------------------------------------------------------{
//Set order blocks
var iob_boxes = array.new_box(0)
var ob_boxes = array.new_box(0)

//Delete internal order blocks box coordinates if top/bottom is broken
for element in iob_type
    index = array.indexof(iob_type, element)

    if close < array.get(iob_btm, index) and element == 1
        array.remove(iob_top, index) 
        array.remove(iob_btm, index) 
        array.remove(iob_left, index) 
        array.remove(iob_type, index)
        bull_iob_break := true

    else if close > array.get(iob_top, index) and element == -1
        array.remove(iob_top, index) 
        array.remove(iob_btm, index)
        array.remove(iob_left, index) 
        array.remove(iob_type, index)
        bear_iob_break := true

//Delete internal order blocks box coordinates if top/bottom is broken
for element in ob_type
    index = array.indexof(ob_type, element)

    if close < array.get(ob_btm, index) and element == 1
        array.remove(ob_top, index) 
        array.remove(ob_btm, index) 
        array.remove(ob_left, index) 
        array.remove(ob_type, index)
        bull_ob_break := true

    else if close > array.get(ob_top, index) and element == -1
        array.remove(ob_top, index) 
        array.remove(ob_btm, index)
        array.remove(ob_left, index) 
        array.remove(ob_type, index)
        bear_ob_break := true

iob_size = array.size(iob_type)
ob_size = array.size(ob_type)

if barstate.isfirst
    if show_iob
        for i = 0 to iob_showlast-1
            array.push(iob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))
    if show_ob
        for i = 0 to ob_showlast-1
            array.push(ob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))

if iob_size > 0
    if barstate.islast
        display_ob(iob_boxes, iob_top, iob_btm, iob_left, iob_type, iob_showlast, false, iob_size)

if ob_size > 0
    if barstate.islast
        display_ob(ob_boxes, ob_top, ob_btm, ob_left, ob_type, ob_showlast, true, ob_size)

//-----------------------------------------------------------------------------}
//EQH/EQL
//-----------------------------------------------------------------------------{
var eq_prev_top = 0.
var eq_top_x = 0

var eq_prev_btm = 0.
var eq_btm_x = 0

if show_eq
    eq_top = ta.pivothigh(eq_len, eq_len)
    eq_btm = ta.pivotlow(eq_len, eq_len)

    if not na(eq_top) 
        max = math.max(eq_top, eq_prev_top)
        min = math.min(eq_top, eq_prev_top)
        
        if max < min + atr * eq_threshold
            eqh_line = line.new(eq_top_x, eq_prev_top, n-eq_len, eq_top
              , color = bear_css
              , style = line.style_dotted)

            eqh_lbl = label.new(int(math.avg(n-eq_len, eq_top_x)), eq_top, 'EQH'
              , color = #00000000
              , textcolor = bear_css
              , style = label.style_label_down
              , size = eqhl_lbl_size)

            if mode == 'Present'
                line.delete(eqh_line[1])
                label.delete(eqh_lbl[1])
            
            eqh_alert := true

        eq_prev_top := eq_top
        eq_top_x := n-eq_len

    if eq_btm 
        max = math.max(eq_btm, eq_prev_btm)
        min = math.min(eq_btm, eq_prev_btm)
        
        if min > max - atr * eq_threshold
            eql_line = line.new(eq_btm_x, eq_prev_btm, n-eq_len, eq_btm
              , color = bull_css
              , style = line.style_dotted)

            eql_lbl = label.new(int(math.avg(n-eq_len, eq_btm_x)), eq_btm, 'EQL'
              , color = #00000000
              , textcolor = bull_css
              , style = label.style_label_up
              , size = eqhl_lbl_size)

            eql_alert := true

            if mode == 'Present'
                line.delete(eql_line[1])
                label.delete(eql_lbl[1])

        eq_prev_btm := eq_btm
        eq_btm_x := n-eq_len

//-----------------------------------------------------------------------------}
//Fair Value Gaps
//-----------------------------------------------------------------------------{
var bullish_fvg_max = array.new_box(0)
var bullish_fvg_min = array.new_box(0)

var bearish_fvg_max = array.new_box(0)
var bearish_fvg_min = array.new_box(0)

float bullish_fvg_avg = na
float bearish_fvg_avg = na

bullish_fvg_cnd = false
bearish_fvg_cnd = false

[src_c1, src_o1, src_h, src_l, src_h2, src_l2] =
  request.security(syminfo.tickerid, fvg_tf, get_ohlc())

if show_fvg
    delta_per = (src_c1 - src_o1) / src_o1 * 100

    change_tf = timeframe.change(fvg_tf)

    threshold = fvg_auto ? ta.cum(math.abs(change_tf ? delta_per : 0)) / n * 2 
      : 0

    //FVG conditions
    bullish_fvg_cnd := src_l > src_h2
      and src_c1 > src_h2 
      and delta_per > threshold
      and change_tf

    bearish_fvg_cnd := src_h < src_l2 
      and src_c1 < src_l2 
      and -delta_per > threshold
      and change_tf

    //FVG Areas
    if bullish_fvg_cnd
        array.unshift(bullish_fvg_max, box.new(n-1, src_l, n + fvg_extend, math.avg(src_l, src_h2)
          , border_color = bull_fvg_css
          , bgcolor = bull_fvg_css))
        
        array.unshift(bullish_fvg_min, box.new(n-1, math.avg(src_l, src_h2), n + fvg_extend, src_h2
          , border_color = bull_fvg_css
          , bgcolor = bull_fvg_css))
    
    if bearish_fvg_cnd
        array.unshift(bearish_fvg_max, box.new(n-1, src_h, n + fvg_extend, math.avg(src_h, src_l2)
          , border_color = bear_fvg_css
          , bgcolor = bear_fvg_css))
        
        array.unshift(bearish_fvg_min, box.new(n-1, math.avg(src_h, src_l2), n + fvg_extend, src_l2
          , border_color = bear_fvg_css
          , bgcolor = bear_fvg_css))

    for bx in bullish_fvg_min
        if low < box.get_bottom(bx)
            box.delete(bx)
            box.delete(array.get(bullish_fvg_max, array.indexof(bullish_fvg_min, bx)))
    
    for bx in bearish_fvg_max
        if high > box.get_top(bx)
            box.delete(bx)
            box.delete(array.get(bearish_fvg_min, array.indexof(bearish_fvg_max, bx)))

//-----------------------------------------------------------------------------}
//Previous day/week high/lows
//-----------------------------------------------------------------------------{
//Daily high/low
[pdh, pdl] = request.security(syminfo.tickerid, 'D', hl()
  , lookahead = barmerge.lookahead_on)

//Weekly high/low
[pwh, pwl] = request.security(syminfo.tickerid, 'W', hl()
  , lookahead = barmerge.lookahead_on)

//Monthly high/low
[pmh, pml] = request.security(syminfo.tickerid, 'M', hl()
  , lookahead = barmerge.lookahead_on)

//Display Daily
if show_pdhl
    phl(pdh, pdl, 'D', pdhl_css)

//Display Weekly
if show_pwhl
    phl(pwh, pwl, 'W', pwhl_css)
    
//Display Monthly
if show_pmhl
    phl(pmh, pml, 'M', pmhl_css)

//-----------------------------------------------------------------------------}
//Premium/Discount/Equilibrium zones
//-----------------------------------------------------------------------------{
var premium = box.new(na, na, na, na
  , bgcolor = color.new(premium_css, 80)
  , border_color = na)

var premium_lbl = label.new(na, na
  , text = 'Premium'
  , color = TRANSP_CSS
  , textcolor = premium_css
  , style = label.style_label_down
  , size = size.small)

var eq = box.new(na, na, na, na
  , bgcolor = color.rgb(120, 123, 134, 80)
  , border_color = na)

var eq_lbl = label.new(na, na
  , text = 'Equilibrium'
  , color = TRANSP_CSS
  , textcolor = eq_css
  , style = label.style_label_left
  , size = size.small)

var discount = box.new(na, na, na, na
  , bgcolor = color.new(discount_css, 80)
  , border_color = na)

var discount_lbl = label.new(na, na
  , text = 'Discount'
  , color = TRANSP_CSS
  , textcolor = discount_css
  , style = label.style_label_up
  , size = size.small)

//Show Premium/Discount Areas
if barstate.islast and show_sd
    avg = math.avg(trail_up, trail_dn)

    box.set_lefttop(premium, math.max(top_x, btm_x), trail_up)
    box.set_rightbottom(premium, n, .95 * trail_up + .05 * trail_dn)

    label.set_xy(premium_lbl, int(math.avg(math.max(top_x, btm_x), n)), trail_up)

    box.set_lefttop(eq, math.max(top_x, btm_x), .525 * trail_up + .475*trail_dn)
    box.set_rightbottom(eq, n, .525 * trail_dn + .475 * trail_up)

    label.set_xy(eq_lbl, n, avg)
    
    box.set_lefttop(discount, math.max(top_x, btm_x), .95 * trail_dn + .05 * trail_up)
    box.set_rightbottom(discount, n, trail_dn)
    label.set_xy(discount_lbl, int(math.avg(math.max(top_x, btm_x), n)), trail_dn)

//-----------------------------------------------------------------------------}
//Trend
//-----------------------------------------------------------------------------{
var color trend_css = na

if show_trend
    if style == 'Colored'
        trend_css := itrend == 1 ? bull_css : bear_css
    else if style == 'Monochrome'
        trend_css := itrend == 1 ? #b2b5be : #5d606b

plotcandle(open, high, low, close
  , color = trend_css
  , wickcolor = trend_css
  , bordercolor = trend_css
  , editable = false)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
//Internal Structure
alertcondition(bull_ibos_alert, 'Internal Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bull_ichoch_alert, 'Internal Bullish CHoCH', 'Internal Bullish CHoCH formed')

alertcondition(bear_ibos_alert, 'Internal Bearish BOS', 'Internal Bearish BOS formed')
alertcondition(bear_ichoch_alert, 'Internal Bearish CHoCH', 'Internal Bearish CHoCH formed')

//Swing Structure
alertcondition(bull_bos_alert, 'Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bull_choch_alert, 'Bullish CHoCH', 'Internal Bullish CHoCH formed')

alertcondition(bear_bos_alert, 'Bearish BOS', 'Bearish BOS formed')
alertcondition(bear_choch_alert, 'Bearish CHoCH', 'Bearish CHoCH formed')

//order Blocks
alertcondition(bull_iob_break, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(bear_iob_break, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')

alertcondition(bull_ob_break, 'Bullish Swing OB Breakout', 'Price broke bullish swing OB')
alertcondition(bear_ob_break, 'Bearish Swing OB Breakout', 'Price broke bearish swing OB')

//EQH/EQL
alertcondition(eqh_alert, 'Equal Highs', 'Equal highs detected')
alertcondition(eql_alert, 'Equal Lows', 'Equal lows detected')

//FVG
alertcondition(bullish_fvg_cnd, 'Bullish FVG', 'Bullish FVG formed')
alertcondition(bearish_fvg_cnd, 'Bearish FVG', 'Bearish FVG formed')

//-----------------------------------------------------------------------------}

// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

 
// # indicator('ICT Macros [LuxAlgo]', overlay = true, max_lines_count = 500, max_labels_count = 100)
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
group_ln     = 'London Time Settings'
lnSummerTime = input.bool(true , 'London Daylight Saving Time (DST)', group = group_ln, tooltip = 'London : Daylight Saving Time (DST)\n - DST Start : Last Sunday in March at 1:00 UTC\n - DST End   : Last Sunday in October at 1:00 UTC')

group_m02 = 'London 02:33 AM 03:00 Macro'
m02330300 = input.bool(false, '02:33 AM 03:00', group = group_m02)
m02_top   = input.bool(true, 'Top Line', inline = 'mc02', group = group_m02)
m02_mid   = input.bool(true, 'Mid Line', inline = 'mc02', group = group_m02)
m02_bot   = input.bool(true, 'Bottom Line', inline = 'mc02', group = group_m02)
m02_ext   = input.bool(true, 'Extending Lines', inline = 'mc02', group = group_m02)

group_m04 = 'London 04:03 AM 04:30 Macro'
m04030430 = input.bool(false, '04:03 AM 04:30', group = group_m04)
m04_top   = input.bool(true, 'Top Line', inline = 'mc04', group = group_m04)
m04_mid   = input.bool(true, 'Mid Line', inline = 'mc04', group = group_m04)
m04_bot   = input.bool(true, 'Bottom Line', inline = 'mc04', group = group_m04)
m04_ext   = input.bool(true, 'Extending Lines', inline = 'mc04', group = group_m04)

group_ny     = 'New York Time Settings'
nySummerTime = input.bool(true , 'New York Daylight Saving Time (DST)', group = group_ny, tooltip = 'New York : Daylight Saving Time (DST)\n - DST Start : Second Sunday in March at 2:00\n - DST End   : First Sunday in November at 2:00')

group_m08 = 'New York 08:50 AM 09:10 Macro'
m08500910 = input.bool(false, '08:50 AM 09:10', group = group_m08)
m08_top   = input.bool(true, 'Top Line', inline = 'mc08', group = group_m08)
m08_mid   = input.bool(true, 'Mid Line', inline = 'mc08', group = group_m08)
m08_bot   = input.bool(true, 'Bottom Line', inline = 'mc08', group = group_m08)
m08_ext   = input.bool(true, 'Extending Lines', inline = 'mc08', group = group_m08)

group_m09 = 'New York 09:50 AM 10:10 Macro'
m09501010 = input.bool(true , '09:50 AM 10:10', group = group_m09)
m09_top   = input.bool(true, 'Top Line', inline = 'mc09', group = group_m09)
m09_mid   = input.bool(true, 'Mid Line', inline = 'mc09', group = group_m09)
m09_bot   = input.bool(true, 'Bottom Line', inline = 'mc09', group = group_m09)
m09_ext   = input.bool(true, 'Extending Lines', inline = 'mc09', group = group_m09)

group_m10 = 'New York 10:50 AM 11:10 Macro'
m10501110 = input.bool(true , '10:50 AM 11:10', group = group_m10)
m10_top   = input.bool(true, 'Top Line', inline = 'mc10', group = group_m10)
m10_mid   = input.bool(true, 'Mid Line', inline = 'mc10', group = group_m10)
m10_bot   = input.bool(true, 'Bottom Line', inline = 'mc10', group = group_m10)
m10_ext   = input.bool(true, 'Extending Lines', inline = 'mc10', group = group_m10)

group_m11 = 'New York 11:50 AM 12:10 Launch Macro'
m11501210 = input.bool(false, '11:50 AM 12:10', group = group_m11)
m11_top   = input.bool(true, 'Top Line', inline = 'mc11', group = group_m11)
m11_mid   = input.bool(true, 'Mid Line', inline = 'mc11', group = group_m11)
m11_bot   = input.bool(true, 'Bottom Line', inline = 'mc11', group = group_m11)
m11_ext   = input.bool(true, 'Extending Lines', inline = 'mc11', group = group_m11)

group_m13 = 'New York 13:10 PM 13:40 Macro'
m13101340 = input.bool(true , '13:10 PM 13:40', group = group_m13)
m13_top   = input.bool(true, 'Top Line', inline = 'mc13', group = group_m13)
m13_mid   = input.bool(true, 'Mid Line', inline = 'mc13', group = group_m13)
m13_bot   = input.bool(true, 'Bottom Line', inline = 'mc13', group = group_m13)
m13_ext   = input.bool(true, 'Extending Lines', inline = 'mc13', group = group_m13)

group_m15 = 'New York 15:15 PM 15:45 Macro'
m15151545 = input.bool(true , '15:15 PM 15:45', group = group_m15)
m15_top   = input.bool(true, 'Top Line', inline = 'mc15', group = group_m15)
m15_mid   = input.bool(true, 'Mid Line', inline = 'mc15', group = group_m15)
m15_bot   = input.bool(true, 'Bottom Line', inline = 'mc15', group = group_m15)
m15_ext   = input.bool(true, 'Extending Lines', inline = 'mc15', group = group_m15)

group_c   = 'Macro Classification'
pLen      = input.int(13, 'Length', minval = 5, maxval = 20, group = group_c)
pLoc      = input.string('Body', 'Swing Area', options = ['Wick', 'Body'], group = group_c)

aColor    = input.color(color.gray, 'Accumulation', group = group_c)
mColor    = input.color(color.red , 'Manipulation', group = group_c)
eColor    = input.color(color.blue, 'Expansion'   , group = group_c)

mcText    = input.string('Small', "Macro Texts", options=['Tiny', 'Small', 'Normal', 'None'])

mcSize = switch mcText
    'Tiny'   => size.tiny
    'Small'  => size.small
    'Normal' => size.normal
    => size.tiny

mcAlert    = input.bool(true, 'Alert Macro Times in Advance (Minutes)', inline = 'alert', tooltip = 'Enabling the option will plot a vertical line for the next macro time prior to the specified minutes\n\nNote: for alert configuration if not on 1 min chart please use round numbers')
mcAlertM   = input.int(30, '', minval = 5, maxval = 60, step = 5, inline = 'alert')

//-----------------------------------------------------------------------------}
//UDT's
//-----------------------------------------------------------------------------{
type bar
    float o = open
    float h = high
    float l = low
    float c = close
    int   t = time

type macro
    int   t         // unix time 
    int   x2        // end bar_index
    int   len       // macro length
    float o         // macro open price value
    float top       // macro top price value
    float bottom    // macro bottom price value
    float mid       // macro mid price value
    float co        // macro close open price value
    float ch        // macro close high price value
    float cl        // macro close low price value
    float cc        // macro close close price value
    line  lnh       // macro top line
    line  lnhe      // macro top line - extended
    line  lnl       // macro bottom line
    line  lnle      // macro bottom line - extended
    line  lnm       // macro mid line
    line  lnme      // macro mid line - extended
    line  lnf       // next macro start
    linefill lf     // macro box (linefill)
    label  lb       // macro label
    string xloc    = xloc.bar_index
    color  color   = chart.fg_color
    color  nocolor = chart.bg_color

type pivotPoint
    int   ht  // pivot high unix time
    int   lt  // pivot low unix time
    float h   // last pivot high price value
    float h1  // previous pivot high price value
    float l   // last pivot low price value
    float l1  // previous pivot low price value

//-----------------------------------------------------------------------------}
//Methods / Functions
//-----------------------------------------------------------------------------{
// @function         updates horizontal line's y1 and y2 value
// @param _ln        (line) line to be updated
// @param _y         (float) The new value
// @returns          none

method set_y(line _ln, float _y) => _ln.set_y1(_y), _ln.set_y2(_y)

// @function              get the current bar's unix time, hour and minute
// @param _utc            (string) utc and major city in the form of '(UTC-05:00) NEW YORK'
// @param _dst            (bool) daylight saving time 
// @param _utcTimeOffset  (array) array storing the utc info 
// @param _utcCity        (array) array storing the major city info 
// @param _inAd           (int) ofsset value in minutes 
// @param _tf_m           (int) timeframe multiplier 
// @returns               A tuple containing (int) index, (int) hour and (int) minute

method f_getBarTime(string _utc, _dst, _utcTimeOffset, _utcCity, _inAd, _tf_m) =>
    utcTime = (array.get(_utcTimeOffset, array.indexof(_utcCity, _utc)) + (_dst ? 1 : 0)) * 3600000 + _inAd * 60000 + time

    h = math.floor(utcTime / 3600000) % 24
    m = math.floor(utcTime / 60000) % 60
    int idx = 0

    if _tf_m == 3
        if m == 48
            m := m + 2
            idx := 2
        else if m == 9
            m := m + 1
            idx := 1
        //else if m == 12 or m == 42
        //    idx := 0
    else if _tf_m == 5
        if (m == 0 and h == 9) or (m == 30 and h == 7)
            m := m + 3
            idx := 3

    [idx, h, m]

// @function         calculate and get customized pivot points high low and time values
// @param _len       (int) length for the pivot points high low calculation
// @param _loc       (string) if set to 'wick' highest/lowest values of the detected pivot points high low will be calculated
//                            if set to 'Body' the highest/lowest values of the candel bodies will be returend as pivot points high low
// @returns          A tuple containing (float) ph - pivot high, (float) pl - pivot low, (int) pht - pivot high unix time (int) plt - pivot low unix time

method f_getPivotPoint(int _len, _loc) =>
    ph  = ta.pivothigh(_len, _len)
    if ph and _loc == 'Body'
        ph  := math.max(open[_len], close[_len])

    pl  = ta.pivotlow (_len, _len)
    if pl and _loc == 'Body'
        pl  := math.min(open[_len], close[_len])

    pht = ph ? time[_len] : na
    plt = pl ? time[_len] : na

    [ph, pl, pht, plt]

//-----------------------------------------------------------------------------}
//Main variables
//-----------------------------------------------------------------------------{
tf_m = timeframe.multiplier
bi   = bar_index

var a_majorCity = array.new_string(), var a_utcTimeOffset = array.new_float(), var a_utcCity = array.new_string()

if barstate.isfirst 
    array.push(a_majorCity, 'NEW YORK'), array.push(a_utcTimeOffset, -5), array.push(a_utcCity, '(UTC-05:00) NEW YORK')
    array.push(a_majorCity, 'LONDON'  ), array.push(a_utcTimeOffset, 0 ), array.push(a_utcCity, '(UTC+00:00) LONDON'  )

// Lower TF bar UDT array 
ltfB = request.security_lower_tf(syminfo.tickerid, '1', bar.new())

// Lower TF pivotPoint UDT arrays
var pivotPoint p = pivotPoint.new()

[a_pH, a_pL, a_pHt, a_pLt] = request.security_lower_tf(syminfo.tickerid, '1', f_getPivotPoint(pLen, pLoc))

if not na(array.min(a_pL))
    p.l  := array.min(a_pL)
    p.lt := array.min(a_pLt) 

if not na(array.max(a_pH))
    p.h  := array.max(a_pH)
    p.ht := array.max(a_pHt)

//-----------------------------------------------------------------------------}
//Detect ICT macros
//-----------------------------------------------------------------------------{
var macro mc = macro.new()

// @function        main function : detects macros, draws nad controls macro components and classifies macros
// @param _m        (bool) enable/disable specific macro 
// @param _msh      (int) macro start hour
// @param _msm      (int) macro start minute
// @param _mh       (bool) macro top line control option
// @param _ml       (bool) macro bottom line control option
// @param _mm       (bool) macro middle line control option
// @param _me       (bool) macro extended lines control option
// @param _mt       (bool) macro label text value
//
// @param _utc      (string) utc and major city in the form of '(UTC-05:00) NEW YORK'
// @param _dst      (bool) daylight saving time 
// @param _tf_m     (int) timeframe multiplier 
// @param _alert    (bool) next macro time start location, displays in _alertM minutes 
// @param _alertM   (int) alert in _alertM minutes 
// @returns         macro UDT components created 

processMacro(_m, _msh, _msm, _mh, _ml, _mm, _me, _mt, _utc, _dst, _tf_m, _alert, _alertM) =>
    if _m

        [_, ha, ma] = f_getBarTime(_utc, _dst, a_utcTimeOffset, a_utcCity, _alertM, _tf_m)

        if ha == _msh and ma == _msm
            alert(_mt + ' macro will be in play in ' + str.tostring(_alertM) + ' minutes for instrument ' + syminfo.ticker)
            
            if _alert
                mc.lnf  := line.new(time + _alertM * 60000 , high, time + _alertM * 60000, low, xloc.bar_time, extend.both, mc.color, line.style_solid , 1)

        [idx, h, m] = f_getBarTime(_utc, _dst, a_utcTimeOffset, a_utcCity, 0, _tf_m)

        if h == 8 or h == 9 or h == 10 or h == 11
            if m == 3
                mc.len := 27
            else
                mc.len := 20
        else if h == 7
            mc.len := 27
        else 
            mc.len := 30

        if h == _msh and  m == _msm
            mc.lnf.delete()
            
            if ltfB.size() > idx
                if not na(ltfB.get(idx).h)
                    mc.t      := ltfB.get(idx).t
                    mc.o      := ltfB.get(idx).o
                    mc.top    := ltfB.get(idx).h
                    mc.bottom := ltfB.get(idx).l

            if idx == 0
                mc.x2 := bi + math.round(mc.len / _tf_m)
            else
                mc.x2 := bi + math.round(mc.len / _tf_m) + 1
            
            mc.lnh  := line.new(bi, mc.top, int(mc.x2), mc.top, color = _mh ? mc.color : mc.nocolor, style = line.style_solid , width = 2)
            mc.lnhe := line.new(int(mc.x2), mc.top, int(mc.x2), mc.top, color = _me ? _mh ? mc.color : mc.nocolor : mc.nocolor, style = line.style_dotted, width = 2)
            
            mc.lnl  := line.new(bi, mc.bottom, int(mc.x2), mc.bottom, color =_ml ? mc.color : mc.nocolor, style = line.style_solid , width = 2)
            mc.lnle := line.new(int(mc.x2), mc.bottom, int(mc.x2), mc.bottom, color = _me ? _ml ? mc.color : mc.nocolor : mc.nocolor, style = line.style_dotted, width = 2)
            
            mc.lnm  := line.new(bi, math.avg(mc.top, mc.bottom), int(mc.x2), math.avg(mc.top, mc.bottom), color = _mm ? mc.color : mc.nocolor, style = line.style_dotted, width = 1)
            mc.lnme := line.new(bi, math.avg(mc.top, mc.bottom), int(mc.x2), math.avg(mc.top, mc.bottom), color = _me ? _mm ? mc.color : mc.nocolor : mc.nocolor, style = line.style_dotted, width = 1)
            
            mc.lf   := linefill.new(mc.lnh, mc.lnl, color.new(color.gray, 100))
            mc.lb   := label.new(bi + int(mc.len / _tf_m / 2), mc.top, mcText != 'None' ? 'MACRO\n' + _mt : '', xloc.bar_index, yloc.price, #00000000, label.style_label_down, chart.fg_color, mcSize, text.align_left, '')
            
            p.l1 := p.l
            p.h1 := p.h

        else if bi < int(mc.x2) and time >= mc.t

            mc.top := math.max(high, mc.lnh.get_y1())
            mc.lnh.set_y(mc.top), mc.lnhe.set_y(mc.top)

            mc.bottom := math.min(low , mc.lnl.get_y1())
            mc.lnl.set_y(mc.bottom), mc.lnle.set_y(mc.bottom)

            mc.mid := math.avg(math.max(high, mc.lnh.get_y1()), math.min(low , mc.lnl.get_y1()))
            mc.lnm.set_y(mc.mid), mc.lnme.set_y(mc.mid)

            mc.lb.set_y(math.max(high, mc.lb.get_y()))

            if not na(array.min(a_pL)) and p.lt < mc.t
                p.l1  := array.min(a_pL)

            if not na(array.max(a_pH)) and p.ht < mc.t
                p.h1  := array.max(a_pH)

        else if bi == int(mc.x2)

            if ltfB.size() > idx
                if not na(ltfB.get(idx).c)
                    mc.co := ltfB.get(idx).o
                    mc.ch := ltfB.get(idx).h
                    mc.cl := ltfB.get(idx).l
                    mc.cc := ltfB.get(idx).c

            mc.top := math.max(mc.ch, mc.lnh.get_y1())
            mc.lnh.set_y(mc.top), mc.lnhe.set_y(mc.top)

            mc.bottom := math.min(mc.cl , mc.lnl.get_y1())
            mc.lnl.set_y(mc.bottom), mc.lnle.set_y(mc.bottom)

            mc.mid := math.avg(math.max(mc.top, mc.lnh.get_y1()), math.min(mc.bottom , mc.lnl.get_y1()))
            mc.lnm.set_y(mc.mid), mc.lnme.set_y(mc.mid)

            mc.lb.set_y(math.max(mc.top, mc.lb.get_y()))

            if not na(array.min(a_pL)) and p.lt < mc.t
                p.l1  := array.min(a_pL)

            if not na(array.max(a_pH)) and p.ht < mc.t
                p.h1  := array.max(a_pH)

        else if mc.t == mc.t[1]

            mc.lnhe.set_x2(bi), mc.lnle.set_x2(bi), mc.lnme.set_x2(bi)


        if bi == int(mc.x2) + 1 and not str.contains(mc.lb.get_text(), 'on MACRO')

            mc.lb.set_tooltip('mc open       : '+ str.tostring(mc.o     , format.mintick) + 
                          '\nmc close      : '  + str.tostring(mc.cc    , format.mintick) + 
                          '\nmc top         : ' + str.tostring(mc.top   , format.mintick) +
                          '\nmc mid        : '  + str.tostring(mc.mid   , format.mintick) + 
                          '\nmc bottom   : '    + str.tostring(mc.bottom, format.mintick) )

            if mc.bottom < p.l1 and mc.top > p.h1
                if (mc.o < math.avg(mc.bottom, mc.mid) and mc.cc > math.avg(mc.top, mc.mid)) or (mc.o > math.avg(mc.top, mc.mid) and mc.cc < math.avg(mc.bottom, mc.mid))
                    mc.lf.set_color(color.new(eColor, 73))
                    if mcText != 'None'
                        mc.lb.set_text('Expansion ' + mc.lb.get_text())
                else
                    mc.lf.set_color(color.new(mColor, 73))
                    if mcText != 'None'
                        mc.lb.set_text('Manipulation ' + mc.lb.get_text())
            else if mc.bottom < p.l1 or mc.top > p.h1 
                if (mc.co > mc.mid and mc.cc < mc.mid) or (mc.co < mc.mid and mc.cc > mc.mid) or (mc.o < mc.mid and mc.cc < mc.mid) or (mc.o > mc.mid and mc.cc > mc.mid) // pL > pmcPL or pmcPH < pH
                    mc.lf.set_color(color.new(aColor, 73))
                    if mcText != 'None'
                        mc.lb.set_text('Accumulation ' + mc.lb.get_text())
                else
                    mc.lf.set_color(color.new(eColor, 73))
                    if mcText != 'None'
                        mc.lb.set_text('Expansion ' + mc.lb.get_text())
            else
                if p.l == p.l1 and p.h == p.h1 and (mc.o < math.avg(mc.bottom, mc.mid) and mc.cc > math.avg(mc.top, mc.mid)) or (mc.o > math.avg(mc.top, mc.mid) and mc.cc < math.avg(mc.bottom, mc.mid))

                    mc.lf.set_color(color.new(eColor, 73))
                    if mcText != 'None'
                        mc.lb.set_text('Expansion ' + mc.lb.get_text())
                else
                    mc.lf.set_color(color.new(aColor, 73))
                    if mcText != 'None' 
                        mc.lb.set_text('Accumulation ' + mc.lb.get_text())

//-----------------------------------------------------------------------------}
//Process macros
//-----------------------------------------------------------------------------{
if tf_m <= 5
    processMacro(m02330300,  7, 33, m02_top,  m02_bot, m02_mid, m02_ext, '02:33 AM - 03:00', '(UTC+00:00) LONDON'  , lnSummerTime, tf_m, mcAlert, mcAlertM)
    processMacro(m04030430,  9,  3, m04_top,  m04_bot, m04_mid, m04_ext, '04:03 AM - 04:30', '(UTC+00:00) LONDON'  , lnSummerTime, tf_m, mcAlert, mcAlertM)

    processMacro(m08500910,  8, 50, m08_top,  m08_bot, m08_mid, m08_ext, '08:50 AM - 09:10', '(UTC-05:00) NEW YORK', nySummerTime, tf_m, mcAlert, mcAlertM)
    processMacro(m09501010,  9, 50, m09_top,  m09_bot, m09_mid, m09_ext, '09:50 AM - 10:10', '(UTC-05:00) NEW YORK', nySummerTime, tf_m, mcAlert, mcAlertM)
    processMacro(m10501110, 10, 50, m10_top,  m10_bot, m10_mid, m10_ext, '10:50 AM - 11:10', '(UTC-05:00) NEW YORK', nySummerTime, tf_m, mcAlert, mcAlertM)
    processMacro(m11501210, 11, 50, m11_top,  m11_bot, m11_mid, m11_ext, '11:50 AM - 12:10', '(UTC-05:00) NEW YORK', nySummerTime, tf_m, mcAlert, mcAlertM)
    processMacro(m13101340, 13, 10, m13_top,  m13_bot, m13_mid, m13_ext, '01:10 PM - 01:40', '(UTC-05:00) NEW YORK', nySummerTime, tf_m, mcAlert, mcAlertM)
    processMacro(m15151545, 15, 15, m15_top,  m15_bot, m15_mid, m15_ext, '03:15 PM - 03:45', '(UTC-05:00) NEW YORK', nySummerTime, tf_m, mcAlert, mcAlertM)
else
    var table note = table.new(position.bottom_right, 1, 1)
    if barstate.islast
        table.cell(note, 0, 0, 'ICT Macros are supported on:\n 1 min, 3 mins and 5 mins charts\n\n', text_size=size.small, text_color=chart.fg_color)

//-----------------------------------------------------------------------------}


//----------- HTF Candles

//indicator("ICT HTF Candles (fadi)", overlay=true, max_boxes_count = 500, max_lines_count = 500, max_bars_back = 5000)

type Candle
    float   o
    float   c
    float   h
    float   l
    int     o_idx
    int     c_idx
    int     h_idx
    int     l_idx
    box     body
    line    wick_up
    line    wick_down

type Trace
    line    o
    line    c
    line    h
    line    l
    label   o_l
    label   c_l
    label   h_l
    label   l_l

type Imbalance
    box    b
    int    idx

type Settings
    bool    htf_1_show
    bool    htf_2_show
    bool    htf_3_show
    bool    htf_4_show
    bool    htf_5_show
    bool    htf_6_show
    string  htf_1
    string  htf_2
    string  htf_3
    string  htf_4
    string  htf_5
    string  htf_6
    int     max_candles_1
    int     max_candles_2
    int     max_candles_3
    int     max_candles_4
    int     max_candles_5
    int     max_candles_6
    color   bull_body
    color   bull_border
    color   bull_wick
    color   bear_body
    color   bear_border
    color   bear_wick
    int     offset
    int     buffer
    int     htf_buffer
    int     width
    bool    trace_show
    bool    trace_1_show
    bool    trace_2_show
    bool    trace_3_show
    bool    trace_4_show
    bool    trace_5_show
    bool    trace_6_show
    color   trace_o_color
    string  trace_o_style
    int     trace_o_size
    color   trace_c_color
    string  trace_c_style
    int     trace_c_size
    color   trace_h_color
    string  trace_h_style
    int     trace_h_size
    color   trace_l_color
    string  trace_l_style
    int     trace_l_size
    bool    label_show
    bool    label_1_show
    bool    label_2_show
    bool    label_3_show
    bool    label_4_show
    bool    label_5_show
    bool    label_6_show
    color   label_color
    string  label_size
    bool    fvg_show
    color   fvg_color
    bool    vi_show
    color   vi_color
    bool    htf_label_show
    color   htf_label_color
    string  htf_label_size

Settings settings = Settings.new()

settings.htf_1_show      := input.bool(true, "HTF 1", inline="htf1")
htf_1                     = input.timeframe("5", "", inline="htf1")
settings.htf_1           := htf_1
settings.max_candles_1   := input.int(10, "", inline="htf1")
settings.htf_2_show      := input.bool(true, "HTF 2", inline="htf2")

htf_2                     = input.timeframe("15", "", inline="htf2")
settings.htf_2           := htf_2
settings.max_candles_2   := input.int(10, "", inline="htf2")
settings.htf_3_show      := input.bool(true, "HTF 3", inline="htf3")
htf_3                     = input.timeframe("60", "", inline="htf3")
settings.htf_3           := htf_3
settings.max_candles_3   := input.int(10, "", inline="htf3")
settings.htf_4_show      := input.bool(true, "HTF 4", inline="htf4")
htf_4                     = input.timeframe("240", "", inline="htf4")
settings.htf_4           := htf_4
settings.max_candles_4   := input.int(4, "", inline="htf4")
settings.htf_5_show      := input.bool(true, "HTF 5", inline="htf5")
htf_5                     = input.timeframe("1D", "", inline="htf5")
settings.htf_5           := htf_5
settings.max_candles_5   := input.int(2, "", inline="htf5")
settings.htf_6_show      := input.bool(true, "HTF 6", inline="htf6")
htf_6                     = input.timeframe("1W", "", inline="htf6")
settings.htf_6           := htf_6
settings.max_candles_6   := input.int(1, "", inline="htf6")
settings.bull_body       := input.color(color.new(color.green, 10), "Body  ", inline="body")
settings.bear_body       := input.color(color.new(color.red, 10), "", inline="body")
settings.bull_border     := input.color(color.new(color.black, 10), "Borders", inline="borders")
settings.bear_border     := input.color(color.new(color.black, 10), "", inline="borders")
settings.bull_wick       := input.color(color.new(color.black, 10), "Wick  ", inline="wick")
settings.bear_wick       := input.color(color.new(color.black, 10), "", inline="wick")
settings.offset          := input.int(10, "padding from current candles", minval = 1)
settings.buffer          := input.int(1, "space between candles", minval = 1, maxval = 4)
settings.htf_buffer      := input.int(10, "space between Higher Timeframes", minval = 1, maxval = 10)
settings.width           := input.int(1, "Candle Width", minval = 1, maxval = 4)*2

settings.htf_label_show  := input.bool(true, "HTF Label           ", inline="HTFlabel")
settings.htf_label_color := input.color(color.new(color.black, 10), "", inline='HTFlabel')
settings.htf_label_size  := input.string(size.large, "", [size.tiny, size.small, size.normal, size.large, size.huge], inline="HTFlabel")

settings.fvg_show        := input.bool(true, "Fair Value Gap   ", group="Imbalance", inline="fvg")
settings.fvg_color       := input.color(color.new(color.gray, 80), "", inline='fvg', group="Imbalance")

settings.vi_show         := input.bool(true, "Volume Imbalance", group="Imbalance", inline="vi")
settings.vi_color        := input.color(color.new(color.red, 50), "", inline='vi', group="Imbalance")

settings.trace_show      := input.bool(true, "Trace lines", group="trace")
settings.trace_o_color   := input.color(color.new(color.gray, 50), "Open  ", inline='1', group="trace")
settings.trace_o_style   := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline='1', group="trace")
settings.trace_o_size    := input.int(1, '', options = [1,2,3,4], inline='1', group="trace")
settings.trace_c_color   := input.color(color.new(color.gray, 50), "Close  ", inline='2', group="trace")
settings.trace_c_style   := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline='2', group="trace")
settings.trace_c_size    := input.int(1, '', options = [1,2,3,4], inline='2', group="trace")
settings.trace_h_color   := input.color(color.new(color.gray, 50), "High   ", inline='3', group="trace")
settings.trace_h_style   := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline='3', group="trace")
settings.trace_h_size    := input.int(1, '', options = [1,2,3,4], inline='3', group="trace")
settings.trace_l_color   := input.color(color.new(color.gray, 50), "Low   ", inline='4', group="trace")
settings.trace_l_style   := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline='4', group="trace")
settings.trace_l_size    := input.int(1, '', options = [1,2,3,4], inline='4', group="trace")

settings.trace_1_show    := input.bool(true, "HTF 1      ", group="trace", inline="traces")
settings.trace_2_show    := input.bool(false, "HTF 2      ", group="trace", inline="traces")
settings.trace_3_show    := input.bool(false, "HTF 3", group="trace", inline="traces")
settings.trace_4_show    := input.bool(false, "HTF 4      ", group="trace", inline="traces2")
settings.trace_5_show    := input.bool(false, "HTF 5      ", group="trace", inline="traces2")
settings.trace_6_show    := input.bool(false, "HTF 6", group="trace", inline="traces2")

settings.label_show      := input.bool(true, "Label ", inline="label")
settings.label_color     := input.color(color.new(color.black, 10), "", inline='label')
settings.label_size      := input.string(size.small, "", [size.tiny, size.small, size.normal, size.large, size.huge], inline="label")

settings.label_1_show    := input.bool(true, "HTF 1      ", inline="labels")
settings.label_2_show    := input.bool(false, "HTF 2      ", inline="labels")
settings.label_3_show    := input.bool(false, "HTF 3", inline="labels")
settings.label_4_show    := input.bool(false, "HTF 4      ", inline="labels2")
settings.label_5_show    := input.bool(false, "HTF 5      ", inline="labels2")
settings.label_6_show    := input.bool(false, "HTF 6", inline="labels2")

// Variables
var Candle[] candles_1        = array.new<Candle>(0)
var Candle[] candles_2        = array.new<Candle>(0)
var Candle[] candles_3        = array.new<Candle>(0)
var Candle[] candles_4        = array.new<Candle>(0)
var Candle[] candles_5        = array.new<Candle>(0)
var Candle[] candles_6        = array.new<Candle>(0)

var Imbalance[] imbalance_1   = array.new<Imbalance>(0)
var Imbalance[] imbalance_2   = array.new<Imbalance>(0)
var Imbalance[] imbalance_3   = array.new<Imbalance>(0)
var Imbalance[] imbalance_4   = array.new<Imbalance>(0)
var Imbalance[] imbalance_5   = array.new<Imbalance>(0)
var Imbalance[] imbalance_6   = array.new<Imbalance>(0)

var label[] htf_labels        = array.new<label>(6)
var Trace[]   traces          = array.new<Trace>(6)

color color_transparent     = #ffffff00
//+------------------------------------------------------------------------------------------------------------+//
//+--- Debugging                                                                                            ---+//
//+------------------------------------------------------------------------------------------------------------+//
var table infobox = table.new(position.top_right, 2, 10, border_width=1)
f_debug(_row, _value) =>
    table.cell(infobox, 0, _row, str.tostring(_row+1), bgcolor=color.white, text_size=size.auto)
    table.cell(infobox, 1, _row, str.tostring(_value), bgcolor=color.white, text_size=size.auto)

f_get_line_style(style) =>
    out = switch style
        '⎯⎯⎯'  => line.style_solid
        '----' => line.style_dashed
        '····' => line.style_dotted

Validtimeframe(tf) =>
    n1 = timeframe.in_seconds()
    n2 = timeframe.in_seconds(tf)
    n3 = n1 % n2
    (n1 < n2 and math.round(n2/n1) == n2/n1)

f_get_htf_text(idx) =>
    tf = ""
    
    switch idx
        1 =>
            tf := settings.htf_1
        2 =>
            tf := settings.htf_2
        3 =>
            tf := settings.htf_3
        4 =>
            tf := settings.htf_4
        5 =>
            tf := settings.htf_5
        6 =>
            tf := settings.htf_6

    formatted = tf
    seconds = timeframe.in_seconds(tf)

    if seconds < 60
        formatted := str.tostring(seconds) + "s"
    else if (seconds / 60) < 60
        formatted := str.tostring((seconds/60)) + "m"
    else if (seconds/60/60) < 24
        formatted := str.tostring((seconds/60/60)) + "H"
    
    formatted

f_show_trace(idx) =>
    switch idx
        1 =>
            settings.trace_show and settings.trace_1_show
        2 =>
            settings.trace_show and settings.trace_2_show
        3 =>
            settings.trace_show and settings.trace_3_show
        4 =>
            settings.trace_show and settings.trace_4_show
        5 =>
            settings.trace_show and settings.trace_5_show
        6 =>
            settings.trace_show and settings.trace_6_show

f_show_labels(idx) =>
    switch idx
        1 =>
            settings.label_show and settings.label_1_show
        2 =>
            settings.label_show and settings.label_2_show
        3 =>
            settings.label_show and settings.label_3_show
        4 =>
            settings.label_show and settings.label_4_show
        5 =>
            settings.label_show and settings.label_5_show
        6 =>
            settings.label_show and settings.label_6_show

f_get_candles_high(candles) =>
    h = 0.0
    if array.size(candles) > 0
        for i = 0 to array.size(candles)-1
            Candle c = array.get(candles, i)
            if c.h > h
                h := c.h

    h

f_compute_label_position(idx) =>
    h = 0.0

    h1c = f_get_candles_high(candles_1)
    if h1c > h
        h:= h1c

    h2c = f_get_candles_high(candles_2)
    if h2c > h
        h := h2c

    h3c = f_get_candles_high(candles_3)
    if h3c > h
        h := h3c

    h4c = f_get_candles_high(candles_4)
    if h4c > h
        h := h4c

    h5c = f_get_candles_high(candles_5)
    if h5c > h
        h := h5c

    h6c = f_get_candles_high(candles_6)
    if h6c > h
        h := h6c
    
    h

f_compute_htf_offset(idx) =>
    o1 = settings.offset
    o2 = settings.offset
    o3 = settings.offset
    o4 = settings.offset
    o5 = settings.offset
    o6 = settings.offset

    if settings.htf_1_show and Validtimeframe(settings.htf_1)
        o2 := o1 + (settings.max_candles_1 * (settings.width + settings.buffer)) + settings.htf_buffer

    if settings.htf_2_show and Validtimeframe(settings.htf_2)
        o3 := o2 + (settings.max_candles_2 * (settings.width + settings.buffer)) + settings.htf_buffer

    if settings.htf_3_show and Validtimeframe(settings.htf_3)
        o4 := o3 + (settings.max_candles_3 * (settings.width + settings.buffer)) + settings.htf_buffer

    if settings.htf_4_show and Validtimeframe(settings.htf_4)
        o5 := o4 + (settings.max_candles_4 * (settings.width + settings.buffer)) + settings.htf_buffer

    if settings.htf_5_show and Validtimeframe(settings.htf_5)
        o6 := o5 + (settings.max_candles_5 * (settings.width + settings.buffer)) + settings.htf_buffer

    switch idx
        1 =>
            o1
        2 =>
            o2
        3 =>
            o3
        4 =>
            o4
        5 =>
            o5
        6 =>
            o6

f_reorder_candles(idx, candles) =>
    
    computed_offset = f_compute_htf_offset(idx)

    size = array.size(candles)
    index = bar_index+settings.offset

    if size > 0
        for i = size-1 to 0
            Candle candle = array.get(candles, i)
            t_buffer = computed_offset + ((settings.width+settings.buffer)*(size-i))
            box.set_left(candle.body, bar_index+ t_buffer)
            box.set_right(candle.body, bar_index+settings.width + t_buffer)
            line.set_x1(candle.wick_up, bar_index+((settings.width)/2) + t_buffer)
            line.set_x2(candle.wick_up, bar_index+((settings.width)/2) + t_buffer)
            line.set_x1(candle.wick_down, bar_index+((settings.width)/2) + t_buffer)
            line.set_x2(candle.wick_down, bar_index+((settings.width)/2) + t_buffer)

    if settings.htf_label_show
        var label l = array.get(htf_labels, idx-1)

        topc = f_compute_label_position(idx)
        left = bar_index+computed_offset+(size*(settings.width+settings.buffer))/2 + (settings.width+settings.buffer)

        if not na(l)
            label.set_xy(l, left, topc)
            1
        else
            l := label.new(left, topc, f_get_htf_text(idx), color=color_transparent, textcolor = settings.htf_label_color, style=label.style_label_down, size = settings.htf_label_size)

            1

f_find_imbalances(candles, imbalance) =>
    if array.size(imbalance) > 0
        for i = array.size(imbalance)-1 to 0
            Imbalance del = array.get(imbalance, i)
            box.delete(del.b)
            array.pop(imbalance)

    if array.size(candles) > 3 and settings.fvg_show
        for i = 1 to array.size(candles) -3
            candle1 = array.get(candles, i)
            candle2 = array.get(candles, i+2)
            candle3 = array.get(candles, i+1)
            if (candle1.l > candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c))
                Imbalance imb = Imbalance.new()
                imb.b := box.new(box.get_left(candle2.body), candle2.h, box.get_right(candle1.body), candle1.l, bgcolor=settings.fvg_color, border_color = color_transparent)
                array.push(imbalance, imb)
            if  (candle1.h < candle2.l and  math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c))
                Imbalance imb = Imbalance.new()
                imb.b := box.new(box.get_right(candle1.body), candle1.h, box.get_left(candle2.body), candle2.l, bgcolor=settings.fvg_color, border_color = color_transparent)
                array.push(imbalance, imb)
            box temp = box.copy(candle3.body)
            box.delete(candle3.body)
            candle3.body := temp

    if array.size(candles) > 2 and settings.vi_show
        for i = 1 to array.size(candles) -2
            candle1 = array.get(candles, i)
            candle2 = array.get(candles, i+1)
            if (candle1.l < candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c))
                Imbalance imb = Imbalance.new()
                imb.b := box.new(box.get_left(candle2.body), math.min(candle1.o, candle1.c), box.get_right(candle1.body), math.max(candle2.o, candle2.c), bgcolor=settings.vi_color, border_color = color_transparent)
                array.push(imbalance, imb)
            if  (candle1.h > candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c))
                Imbalance imb = Imbalance.new()
                imb.b := box.new(box.get_right(candle1.body),  math.min(candle2.o, candle2.c), box.get_left(candle2.body), math.max(candle1.o, candle1.c), bgcolor=settings.vi_color, border_color = color_transparent)
                array.push(imbalance, imb)
        
f_render_candles(htf, max, candles) =>
    HTFBarTime = time(htf)
    isNewHTFCandle = ta.change(HTFBarTime)
    log.info("Render {0}: {1}", htf, isNewHTFCandle)
    if isNewHTFCandle
        Candle candle = Candle.new()
        candle.o    := open
        candle.c    := close
        candle.h    := high
        candle.l    := low
        candle.o_idx    := bar_index
        candle.c_idx    := bar_index
        candle.h_idx    := bar_index
        candle.l_idx    := bar_index

        bull = candle.c > candle.o
        index = bar_index

        candle.body         := box.new(index, math.max(candle.o, candle.c), index, math.min(candle.o, candle.c), bull ? settings.bull_border : settings.bear_border, 1, bgcolor = bull ? settings.bull_body : settings.bear_body)
        candle.wick_up      := line.new(index, candle.h, index, math.max(candle.o, candle.c), color=bull ? settings.bull_wick : settings.bear_wick)
        candle.wick_down    := line.new(index, math.min(candle.o, candle.c), index, candle.l, color=bull ? settings.bull_wick : settings.bear_wick)

        array.unshift(candles, candle)

        if array.size(candles) > max
            Candle delCandle = array.pop(candles)
            box.delete(delCandle.body)
            line.delete(delCandle.wick_up)
            line.delete(delCandle.wick_down)


f_update_last(idx, candles, imbalance) =>
    if array.size(candles) > 0
        Candle candle = array.get(candles, 0)
        candle.h_idx    := high > candle.h ? bar_index : candle.h_idx
        candle.h        := high > candle.h ? high : candle.h
        candle.l_idx    := low < candle.l ? bar_index : candle.l_idx
        candle.l        := low < candle.l ? low : candle.l
        candle.c        := close
        candle.c_idx    := bar_index
        
        bull = candle.c > candle.o

        box.set_top(candle.body, candle.o)
        box.set_bottom(candle.body, candle.c)
        box.set_bgcolor(candle.body, bull ? settings.bull_body : settings.bear_body)
        box.set_border_color(candle.body, bull ? settings.bull_border : settings.bear_border)
        line.set_color(candle.wick_up, bull ? settings.bull_wick : settings.bear_wick)
        line.set_color(candle.wick_down, bull ? settings.bull_wick : settings.bear_wick)

        line.set_y1(candle.wick_up, candle.h)
        line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
        line.set_y1(candle.wick_down, candle.l)
        line.set_y2(candle.wick_down, math.min(candle.o, candle.c))

        if barstate.isrealtime or barstate.islast
            f_reorder_candles(idx, candles)

        if barstate.isrealtime or barstate.islast
            if f_show_trace(idx)
                var Trace trace = array.get(traces, idx-1)
                if na(trace)
                    trace := Trace.new()

                if na(trace.o)
                    trace.o := line.new(candle.o_idx, candle.o, box.get_left(candle.body), candle.o, color=settings.trace_o_color, style=f_get_line_style(settings.trace_o_style), width=settings.trace_o_size)
                    1
                else
                    line.set_y1(trace.o, candle.o)
                    line.set_y2(trace.o, candle.o)
                    line.set_x2(trace.o, box.get_left(candle.body))

                if na(trace.c)
                    trace.c := line.new(candle.c_idx, candle.c, box.get_left(candle.body), candle.c, color=settings.trace_c_color, style=f_get_line_style(settings.trace_c_style), width=settings.trace_c_size)
                else
                    line.set_y1(trace.c, candle.c)
                    line.set_y2(trace.c, candle.c)
                    line.set_x2(trace.c, box.get_left(candle.body))

                if na(trace.h)
                    trace.h := line.new(candle.h_idx, candle.h, line.get_x1(candle.wick_up), candle.h, color=settings.trace_h_color, style=f_get_line_style(settings.trace_h_style), width=settings.trace_h_size)
                else
                    line.set_y1(trace.h, candle.h)
                    line.set_y2(trace.h, candle.h)
                    line.set_x2(trace.h, line.get_x1(candle.wick_up))

                if na(trace.l)
                    trace.l := line.new(candle.l_idx, candle.l, line.get_x1(candle.wick_down), candle.l, color=settings.trace_l_color, style=f_get_line_style(settings.trace_l_style), width=settings.trace_l_size)
                    1
                else
                    line.set_y1(trace.l, candle.l)
                    line.set_y2(trace.l, candle.l)
                    line.set_x2(trace.l, line.get_x1(candle.wick_down))
                    1

            if f_show_labels(idx)
                var Trace trace = array.get(traces, idx-1)
                if na(trace)
                    trace := Trace.new()

                if na(trace.o_l)
                    trace.o_l := label.new(box.get_right(candle.body), candle.o, str.tostring(candle.o),  textalign = text.align_center, style=label.style_label_left, size=settings.label_size, color=color_transparent, textcolor=settings.label_color)
                    1
                else
                    label.set_y(trace.o_l, candle.o)
                    label.set_x(trace.o_l, box.get_right(candle.body))
                    label.set_text(trace.o_l, str.tostring(candle.o))
                    1
        
                if na(trace.c_l)
                    trace.c_l := label.new(box.get_right(candle.body), candle.c, str.tostring(candle.c),  textalign = text.align_center, style=label.style_label_left, size=settings.label_size, color=color_transparent, textcolor=settings.label_color)
                    1
                else
                    label.set_y(trace.c_l, candle.c)
                    label.set_x(trace.c_l, box.get_right(candle.body))
                    label.set_text(trace.c_l, str.tostring(candle.c))
                    1
                if na(trace.h_l)
                    trace.h_l := label.new(box.get_right(candle.body), candle.h, str.tostring(candle.h),  textalign = text.align_center, style=label.style_label_left, size=settings.label_size, color=color_transparent, textcolor=settings.label_color)
                    1
                else
                    label.set_y(trace.h_l, candle.h)
                    label.set_x(trace.h_l, box.get_right(candle.body))
                    label.set_text(trace.h_l, str.tostring(candle.o))
                    1

                if na(trace.l_l)
                    trace.l_l := label.new(box.get_right(candle.body), candle.l, str.tostring(candle.l),  textalign = text.align_center, style=label.style_label_left, size=settings.label_size, color=color_transparent, textcolor=settings.label_color)
                    1
                else
                    label.set_y(trace.l_l, candle.l)
                    label.set_x(trace.l_l, box.get_right(candle.body))
                    label.set_text(trace.l_l, str.tostring(candle.o))
                    1
        
        f_find_imbalances(candles, imbalance)

log.info("{0}", Validtimeframe(settings.htf_5))
if settings.htf_1_show and Validtimeframe(settings.htf_1)
    f_render_candles(settings.htf_1, settings.max_candles_1, candles_1)
if settings.htf_2_show and Validtimeframe(settings.htf_2)
    f_render_candles(settings.htf_2, settings.max_candles_2, candles_2)
if settings.htf_3_show and Validtimeframe(settings.htf_3)
    f_render_candles(settings.htf_3, settings.max_candles_3, candles_3)
if settings.htf_4_show and Validtimeframe(settings.htf_4)
    f_render_candles(settings.htf_4, settings.max_candles_4, candles_4)
if settings.htf_5_show and Validtimeframe(settings.htf_5)
    f_render_candles(settings.htf_5, settings.max_candles_5, candles_5)
if settings.htf_6_show and Validtimeframe(settings.htf_6)
    f_render_candles(settings.htf_6, settings.max_candles_6, candles_6)

if settings.htf_1_show
    f_update_last(1, candles_1, imbalance_1)
if settings.htf_2_show
    f_update_last(2, candles_2, imbalance_2)
if settings.htf_3_show
    f_update_last(3, candles_3, imbalance_3)
if settings.htf_4_show
    f_update_last(4, candles_4, imbalance_4)
if settings.htf_5_show
    f_update_last(5, candles_5, imbalance_5)
if settings.htf_6_show
    f_update_last(6, candles_6, imbalance_6)


 ///// otros

 
// volume color bars
useBarcolor = input.bool(title='color bar', defval = true, tooltip = 'bar color based on buy/sell volume, instead of open/close')

volLength = input.int(title='volume length', tooltip='how many candles will use to calculate volume strength', minval=1, step=1, defval=30)
inputVolumeFactorMid = input.float(title='Volume factor Mid', minval=0.5, step=0.1, defval=0.5, tooltip = 'new candle vol VS prev.candles vol average')
inputVolumeFactorHigh = input.float(title='Volume factor High', minval=0.5, step=0.1, defval=1.5, tooltip = 'new candle vol VS prev.candles vol average')

avrg = ta.sma(volume, volLength)

// rojos
volrojoalto = volume > avrg * inputVolumeFactorHigh and close < open
volrojomedio = volume >= avrg * inputVolumeFactorMid and volume <= avrg * inputVolumeFactorHigh and close < open
volrojobajo = volume < avrg * inputVolumeFactorMid and close < open

//verdes
volverdealto = volume > avrg * 1.5 and close > open
volverdemedio = volume >= avrg * 0.5 and volume <= avrg * 1.5 and close > open
volverdebajo = volume < avrg * 0.5 and close > open


colrojooscuro = color.rgb(136, 14, 79, 30)
colrojo = color.rgb(255, 82, 82, 30)
colrojoclaro = color.rgb(255, 153, 0, 30)

colverdeoscuro = color.rgb(0, 50, 0, 30)
colverde = color.rgb(0, 150, 0, 30)
colverdeclaro = color.rgb(0, 250, 0, 30)


color = volrojoalto ? colrojooscuro : volrojomedio ? colrojo : volrojobajo ? colrojoclaro : volverdealto ? colverdeoscuro : volverdemedio ? colverde : volverdebajo ? colverdeclaro : na

// colorear barras si el volumen de compra es mayor que el de ventas de verde(ish).. (a pesar q la vela es roja/venta)
// o de rojo(ish) si el volumen de venta es mayor al de compras (a pesar q la vela es verde/compra)
// esto sucede con las velas martillo...(MECHA grande, cuerpo pequeño)
buyVolume  =  (high==low)? 0: volume*(close-low)/(high-low)  
sellVolume =  (high==low)? 0: volume*(high-close)/(high-low) 

if useBarcolor
    if buyVolume>sellVolume
        color := volverdealto ? colverdeoscuro : volverdemedio ? colverde : volverdebajo ? colverdeclaro : color.green
        // color := color.from_gradient(ta.rsi(volume,length), 0, 100,  colverdeclaro, colverdeoscuro)
    if sellVolume>buyVolume
        color := volrojoalto ? colrojooscuro : volrojomedio ? colrojo : volrojobajo ? colrojoclaro : color.red
        // color := color.from_gradient(ta.rsi(volume,length), 0, 100,  colrojoclaro, colrojooscuro)

barcolor(color)

// vwap
showVWAP = input(title='VWAP', defval=true, group="vwap", inline="vwap")
plotVWAPColor = input.color(color.teal, title="color", group="vwap", inline="vwap")

vwapValue = ta.vwap(close)

if showVWAP
    var label wvapLabel = label.new(bar_index, vwapValue, '----- VWAP', xloc=xloc.bar_time, yloc=yloc.price, color=color.green, style=label.style_none, textcolor=color.lime, size=size.small)
    label.set_x(wvapLabel, int(currentTime + 18* minBarTime)) 
    label.set_y(wvapLabel, vwapValue)
// Plot VWAP current temporality
plot(showVWAP ? vwapValue : na, color=plotVWAPColor, linewidth=2)



 // rsi background oversold, overbought
inputShowOverSoldBoughtOverlay = input.bool(title='Show oversold/overbought overlay?', tooltip='overlay oversold/overbought', defval=true, group="OB/OS overlay")
len = input.int(title='rsi len', minval=1, step=1, defval=14, group="OB/OS overlay")
overbought = input.int(title="OB", defval=70, group="OB/OS overlay", inline="OB")
oversold = input.int(title="OS", defval=30, group="OB/OS overlay", inline="OS")
plotOBColor = input.color(color.new(#2a8ba9, 85), group="OB/OS overlay", inline="OB")
plotOSColor = input.color(color.new(#dd52ba, 85), group="OB/OS overlay", inline="OS")

barsToPaint = 1
bgcolor(inputShowOverSoldBoughtOverlay and ta.barssince(ta.rsi(close, len) >= overbought) < barsToPaint ? plotOBColor : na)
bgcolor(inputShowOverSoldBoughtOverlay and ta.barssince(ta.rsi(close, len) <= oversold) < barsToPaint ? plotOSColor : na) 



//----------------
// bolinger bands
//----------------
inputShowBolinger = input.bool(title='Show bolinger', tooltip='show bolinger bars', defval=true)
bolingerlength = input.int(title='bolinger length', minval=1, step=1, defval=20)
src = input.source(close, title="Source")
mult = input.float(defval=2.0, minval=0.001, maxval=10, step=0.2)

basis = ta.sma(src, bolingerlength)
dev = mult * ta.stdev(src, bolingerlength)
upper = basis + dev
lower = basis - dev
plot(inputShowBolinger? basis:na, color=color.red) //sma
p1a = plot(inputShowBolinger ? upper : na, color= color.orange)
p1b = plot(inputShowBolinger ? lower : na, color= color.orange)
fill(p1a, p1b, color= color.rgb(85, 116, 228, 95))



// # // vertical line at 8:30am
// # inputShow830am = input.bool(title='day open', tooltip='show where day open start', defval=true, group="watch day open")
// # plot830Color = input.color(color.new(#84e00a, 18), group="watch day open", inline="0830")
// # input_0830session = input.session("0830-0831", "",  group="watch day open", inline="0830")
// # targetTime = time(timeframe.period, input_0830session, gmt_tz)
// 
// # // targetTime = timestamp(gmt_tz, year, month, dayofmonth, 8, 30, 00)
// # if inputShow830am
// #     line.new(x1=targetTime, y1=low, x2=targetTime, y2=high, xloc=xloc.bar_time, extend=extend.both, color=plot830Color, style=line.style_solid, width=2)
